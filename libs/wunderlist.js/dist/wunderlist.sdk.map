{
  "version": 3,
  "sources": [
    "wunderlist.sdk/node_modules/gulp-cjs/node_modules/browserify/node_modules/browser-pack/_prelude.js",
    "wunderlist.sdk/node_modules/gulp-cjs/node_modules/browserify/node_modules/process/browser.js",
    "wunderlist.sdk/node_modules/magiconsole/public/MagiConsole.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/BaseEventEmitter.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/BaseSingleton.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBClass.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBDeferred.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBEventEmitter.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBPromise.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBSingleton.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/WBStateModel.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/index.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/assert.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/clone.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/createUID.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/debounce.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/defer.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/delay.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/events.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/extend.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/forEach.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/fromSuper.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/functions.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/index.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/inherits.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/isEqual.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/merge.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/size.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/toArray.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/when.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/lib/where.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/ControllableMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/ObservableHashMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/WBBindableMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/WBDestroyableMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/WBEventsMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/WBStateMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/WBUtilsMixin.js",
    "wunderlist.sdk/node_modules/wunderbits.core/public/mixins/index.js",
    "wunderlist.sdk/public/config/default.js",
    "wunderlist.sdk/public/deferreds/RequestDeferred.js",
    "wunderlist.sdk/public/deferreds/RestSocketRequestDeferred.js",
    "wunderlist.sdk/public/helpers/HealthCheck.js",
    "wunderlist.sdk/public/helpers/PlatformHeaders.js",
    "wunderlist.sdk/public/helpers/URL.js",
    "wunderlist.sdk/public/io/IO.js",
    "wunderlist.sdk/public/io/IOBase.js",
    "wunderlist.sdk/public/io/RestSocket.js",
    "wunderlist.sdk/public/io/io/AjaxTransport.js",
    "wunderlist.sdk/public/io/io/NativeWebSocket.js",
    "wunderlist.sdk/public/io/io/NativeXMLHttpRequest.js",
    "wunderlist.sdk/public/io/io/WebSocket.js",
    "wunderlist.sdk/public/io/mixins/RequestQueueMixin.js",
    "wunderlist.sdk/public/models/ApplicationState.js",
    "wunderlist.sdk/public/schemas/BaseSchema.js",
    "wunderlist.sdk/public/schemas/Folder.js",
    "wunderlist.sdk/public/schemas/List.js",
    "wunderlist.sdk/public/schemas/Membership.js",
    "wunderlist.sdk/public/schemas/Note.js",
    "wunderlist.sdk/public/schemas/Organization.js",
    "wunderlist.sdk/public/schemas/Position.js",
    "wunderlist.sdk/public/schemas/Reminder.js",
    "wunderlist.sdk/public/schemas/SchemaTypes.js",
    "wunderlist.sdk/public/schemas/Service.js",
    "wunderlist.sdk/public/schemas/Setting.js",
    "wunderlist.sdk/public/schemas/Subtask.js",
    "wunderlist.sdk/public/schemas/Task.js",
    "wunderlist.sdk/public/schemas/TaskComment.js",
    "wunderlist.sdk/public/schemas/Team.js",
    "wunderlist.sdk/public/schemas/User.js",
    "wunderlist.sdk/public/schemas/index.js",
    "wunderlist.sdk/public/services/Activities.js",
    "wunderlist.sdk/public/services/AuthenticatedService.js",
    "wunderlist.sdk/public/services/Conversations.js",
    "wunderlist.sdk/public/services/Export.js",
    "wunderlist.sdk/public/services/Features.js",
    "wunderlist.sdk/public/services/Files.js",
    "wunderlist.sdk/public/services/IcalFeed.js",
    "wunderlist.sdk/public/services/Import.js",
    "wunderlist.sdk/public/services/ListPositions.js",
    "wunderlist.sdk/public/services/ListRemindersCollections.js",
    "wunderlist.sdk/public/services/Lists.js",
    "wunderlist.sdk/public/services/Memberships.js",
    "wunderlist.sdk/public/services/Mixins/BaseServiceMixin.js",
    "wunderlist.sdk/public/services/Mixins/ServiceCreate.js",
    "wunderlist.sdk/public/services/Mixins/ServiceDelete.js",
    "wunderlist.sdk/public/services/Mixins/ServiceGet.js",
    "wunderlist.sdk/public/services/Mixins/ServiceUpdate.js",
    "wunderlist.sdk/public/services/Notes.js",
    "wunderlist.sdk/public/services/Previews.js",
    "wunderlist.sdk/public/services/Reminders.js",
    "wunderlist.sdk/public/services/Root.js",
    "wunderlist.sdk/public/services/Service.js",
    "wunderlist.sdk/public/services/ServiceGetOnly.js",
    "wunderlist.sdk/public/services/Services.js",
    "wunderlist.sdk/public/services/Settings.js",
    "wunderlist.sdk/public/services/SubtaskPositions.js",
    "wunderlist.sdk/public/services/Subtasks.js",
    "wunderlist.sdk/public/services/TaskComments.js",
    "wunderlist.sdk/public/services/TaskCommentsStates.js",
    "wunderlist.sdk/public/services/TaskPositions.js",
    "wunderlist.sdk/public/services/Tasks.js",
    "wunderlist.sdk/public/services/TasksCounts.js",
    "wunderlist.sdk/public/services/UnreadActivitiesCounts.js",
    "wunderlist.sdk/public/services/Uploads.js",
    "wunderlist.sdk/public/services/User.js",
    "wunderlist.sdk/public/services/Users.js",
    "wunderlist.sdk/public/services/index.js",
    "wunderlist.sdk/public/validators/SchemaValidator.js",
    "wunderlist.sdk/public/wunderbits/WBOnlineStatus.js",
    "wunderlist.sdk/public/wunderbits/lib/SafeParse.js",
    "wunderlist.sdk/public/wunderbits/lib/bindAll.js",
    "wunderlist.sdk/public/wunderlist/Wunderlist.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "wunderlist.sdk",
  "sourceRoot": "file://",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n",
    "(function (process,global){\n'use strict';\n\nvar isBrowser = process.browser;\nif (isBrowser && global.MagiConsole) {\n  module.exports = global.MagiConsole;\n}\nelse {\n  var Console = global.console;\n  var WBClass = require('wunderbits.core/public/WBClass');\n  var assert =  require('wunderbits.core/public/lib/assert');\n  var functions =  require('wunderbits.core/public/lib/functions');\n  var toArray = require('wunderbits.core/public/lib/toArray');\n\n  var _logLevels = {\n    'error': 3,\n    'warn': 4,\n    'log': 5,\n    'info': 6,\n    'debug': 7\n  };\n  var _normalLoggers = Object.keys(_logLevels);\n\n  var _colors = {\n    'blue': '\\x1B[34m',\n    'cyan': '\\x1B[36m',\n    'green': '\\x1B[32m',\n    'grey': '\\x1B[90m',\n    'magenta': '\\x1B[35m',\n    'red': '\\x1B[31m',\n    'white': '\\x1B[37m',\n    'yellow': '\\x1B[33m'\n  };\n  var _colorTerminator = '\\x1B[39m';\n\n  var _colorMap = {\n    'debug': 'cyan',\n    'error': 'red',\n    'info': 'grey',\n    'log': 'white',\n    'warn': 'yellow'\n  };\n\n  // let there be debug!\n  _normalLoggers.forEach(function (logger) {\n    if (typeof Console[logger] !== 'function') {\n      Console[logger] = Console.log;\n    }\n  });\n\n  var MagiConsolePrototype = {\n\n    'constructor': function (namespace) {\n\n      var self = this;\n\n      assert.string(namespace, 'namespace must be a string');\n\n      // if a cached namespaced logger already exists, simply return it\n      var namespaceMap = MagiConsole.namespaces;\n      if (namespaceMap[namespace] instanceof MagiConsole) {\n        return namespaceMap[namespace];\n      }\n\n      self.namespace = namespace;\n      namespaceMap[namespace] = self;\n\n      WBClass.call(self);\n    },\n\n    'shouldRunLevel': function (method) {\n\n      var currentLevel = _logLevels[MagiConsole.level];\n      var methodLevel = _logLevels[method];\n\n      if (currentLevel === undefined || methodLevel === undefined) {\n        return true;\n      }\n      else {\n        return MagiConsole.levelOnly ? methodLevel === currentLevel : methodLevel <= currentLevel;\n      }\n    },\n\n    'shouldRun': function (method) {\n\n      var self = this;\n      var pattern = MagiConsole.pattern;\n      var level = MagiConsole.level;\n\n      var shouldRun = pattern && pattern.test(self.namespace);\n      shouldRun = shouldRun && (level ? self.shouldRunLevel(method) : true);\n      return !!(shouldRun && Console);\n    },\n\n    'colorizeString': function (string, color) {\n\n      return _colors[color] + string + _colorTerminator;\n    },\n\n    'colorizeNamespace': function (string, method) {\n\n      var color = _colorMap[method];\n      if (color) {\n        string = this.colorizeString(string, color);\n      }\n\n      return string;\n    },\n\n    'colorizeStrings': function (method, args) {\n\n      var self = this;\n\n      args.forEach(function (arg, index) {\n\n        if (typeof arg === 'string') {\n          args[index] = self.colorizeNamespace(arg, method);\n        }\n      });\n\n      return args;\n    },\n\n    'injectNamespace': function (method, args) {\n\n      var self = this;\n\n      if (_normalLoggers.indexOf(method) >= 0) {\n        args = toArray(args);\n        var namespaceString = '[' + self.namespace.toUpperCase() + ']';\n        if (typeof args[0] === 'string') {\n          args[0] = namespaceString + ' ' + args[0];\n        }\n        else {\n          args.unshift(namespaceString);\n        }\n\n        !isBrowser && self.colorizeStrings(method, args);\n      }\n\n      return args;\n    }\n  };\n\n  functions(Console).forEach(function (method) {\n\n    MagiConsolePrototype[method] = function methodWrapper () {\n\n      var self = this;\n      var args = arguments;\n      if (self.shouldRun(method)) {\n        args = self.injectNamespace(method, args);\n        Console[method].apply(Console, args);\n      }\n    };\n  });\n\n  var MagiConsole = WBClass.extend(MagiConsolePrototype);\n\n  MagiConsole.release = function () {\n\n    MagiConsole.namespaces = {};\n  };\n\n  MagiConsole.reset = MagiConsole.off = function () {\n\n    MagiConsole.pattern = undefined;\n    MagiConsole.level = undefined;\n    MagiConsole.levelOnly = false;\n  };\n\n  MagiConsole.setPattern = function (regexPatternString) {\n\n    assert.string(regexPatternString, 'regexPatternString must be a string');\n    regexPatternString = regexPatternString === '*' ? '.?' : regexPatternString;\n    MagiConsole.pattern = new RegExp(regexPatternString);\n  };\n\n  MagiConsole.setLevel = function (logLevel, levelOnly) {\n\n    assert.string(logLevel, 'logLevel must be a string');\n    logLevel = logLevel === '*' ? undefined : logLevel;\n    MagiConsole.level = logLevel;\n    MagiConsole.levelOnly = !!levelOnly;\n  };\n\n  if (!isBrowser) {\n    var env = process.env;\n    var envPattern = env.MLOG;\n    var envLevel = env.MLEVEL;\n    envPattern && MagiConsole.setPattern(envPattern);\n    envLevel && MagiConsole.setLevel(envLevel, env.MLEVELONLY === 'true');\n  }\n\n  MagiConsole.release();\n  MagiConsole.reset();\n\n  module.exports = MagiConsole;\n}\n\n}).call(this,require(\"Rdh0rp\"),typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\nvar BaseEmitter = require('./WBEventEmitter').extend({\n  'mixins': [\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseEmitter;\n",
    "'use strict';\n\nvar BaseSingleton = require('./WBSingleton').extend({\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBDestroyableMixin'),\n    require('./mixins/WBUtilsMixin'),\n    require('./mixins/ObservableHashMixin')\n  ]\n});\n\nmodule.exports = BaseSingleton;\n",
    "'use strict';\n\nvar inherits = require('./lib/inherits');\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar createUID = require('./lib/createUID');\nvar fromSuper = require('./lib/fromSuper');\n\n// Self-propagating extend function.\n// Create a new class,\n// that inherits from the class found in the `this` context object.\n// This function is meant to be called,\n// in the context of a constructor function.\nfunction extendSelf (protoProps, staticProps) {\n  /* jshint validthis:true */\n\n  var parent = this;\n\n  protoProps = protoProps || {};\n\n  // extract mixins, if any\n  var mixins = protoProps.mixins || [];\n  delete protoProps.mixins;\n\n  // create the derived class\n  var child = inherits(parent, protoProps, staticProps);\n\n  // apply mixins to the derived class\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyToClass === 'function') &&\n      mixin.applyToClass(child);\n  }\n\n  // make the child class extensible\n  child.extend = parent.extend || extendSelf;\n  return child;\n}\n\nfunction WBClass (options) {\n\n  var self = this;\n\n  // Assign a unique identifier to the instance\n  self.uid = self.uid || createUID();\n\n  // save options, make sure it's at least an empty object\n  self.options = options || self.options;\n\n  // augment properties from mixins\n  self.augmentProperties();\n\n  // initialize the instance\n  self.initialize.apply(self, arguments);\n\n  // initialize all the mixins, if needed\n  // don't keep this in the initialize,\n  // initialize can be overwritten\n  self.initMixins.apply(self, arguments);\n}\n\nvar proto = {\n\n  'initialize': function () {\n\n    // Return self to allow for subclass to assign\n    // super initializer value to self\n    var self = this;\n    return self;\n  },\n\n  // If any mixins were applied to the prototype, initialize them\n  'initMixins': function () {\n\n    var self = this;\n    var initializers = fromSuper.concat(self, 'initializers');\n\n    var initializer;\n    while (initializers.length) {\n      initializer = initializers.shift();\n      (typeof initializer === 'function') &&\n        initializer.apply(self, arguments);\n    }\n  },\n\n  // If any proerties were defined in the mixins, augment them to the instance\n  'augmentProperties': function () {\n\n    var self = this;\n    var properties = fromSuper.merge(self, 'properties');\n\n    function augmentProperty (property, value) {\n\n      var type = typeof value;\n\n      if (type === 'function') {\n        self[property] = value.call(self);\n      }\n      else if (type === 'object') {\n        self[property] = clone(value, true);\n      }\n      else {\n        self[property] = value;\n      }\n    }\n\n    for (var key in properties) {\n      augmentProperty(key, properties[key]);\n    }\n  }\n};\n\nextend(WBClass.prototype, proto);\nWBClass.extend = extendSelf;\n\nmodule.exports = WBClass;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\nvar WBPromise = require('./WBPromise');\nvar assert = require('./lib/assert');\nvar toArray = require('./lib/toArray');\n\nvar states = {\n  'pending': 0,\n  'resolved': 2,\n  'rejected': 4\n};\n\nvar stateNames = {\n  0: ['pending'],\n  2: ['resolved', 'resolve'],\n  4: ['rejected', 'reject']\n};\n\nvar proto = {\n\n  'properties': {\n    '_state': states.pending,\n    '_args': [],\n    'handlers': []\n  },\n\n  'initialize': function (context) {\n    var self = this;\n    self._context = context;\n  },\n\n  'state': function () {\n    var self = this;\n    return stateNames[self._state][0];\n  },\n\n  'trigger': function (withContext) {\n\n    var self = this;\n    if (self._state === states.pending) {\n      return;\n    }\n\n    var handlers = self.handlers, handle;\n    while (handlers.length) {\n      handle = handlers.shift();\n      self.invoke(handle, withContext || self._context);\n    }\n  },\n\n  'invoke': function (deferredResponse, withContext) {\n\n    var self = this;\n    var state = self._state;\n    var context = deferredResponse.context || withContext || self;\n    var args = deferredResponse.args;\n\n    self._args.forEach(function (arg) {\n      // send single arguments as the item, otherwise send it as an array\n      args.push(arg);\n    });\n\n    var type = deferredResponse.type;\n    var isCompleted = (type === 'then') ||\n      (type === 'done' && state === states.resolved) ||\n      (type === 'fail' && state === states.rejected);\n\n    isCompleted && deferredResponse.fn.apply(context, args);\n  },\n\n  'promise': function () {\n    var self = this;\n    self._promise = self._promise || new WBPromise(this);\n    return self._promise;\n  }\n};\n\n['then', 'done', 'fail'].forEach(function (method) {\n  proto[method] = function () {\n\n    var self = this;\n\n    // store references to the context, callbacks, and arbitrary arguments\n    var args = toArray(arguments);\n    var fn = args.shift();\n    var context = args.shift();\n\n    assert.function(fn, method + ' accepts only functions');\n\n    self.handlers.push({\n      'type': method,\n      'context': context,\n      'fn': fn,\n      'args': args\n    });\n\n    // if the defered is not pending anymore, call the callbacks\n    self.trigger();\n\n    return self;\n  };\n});\n\n// Alias `always` to `then` on Deferred's prototype\nproto.always = proto.then;\n\nfunction resolver (state, isWith, fnName) {\n  return function complete () {\n\n    var self = this;\n\n    if (!(self instanceof WBDeferred)) {\n      throw new Error(fnName + ' invoked with wrong context');\n    }\n\n    // can't change state once resolved or rejected\n    if (self._state !== states.pending) {\n      return self;\n    }\n\n    self._args = toArray(arguments);\n    var context = isWith ? self._args.shift() : undefined;\n\n    self._state = state;\n    self.trigger(context);\n\n    return self;\n  };\n}\n\n[states.resolved, states.rejected].forEach(function (state) {\n  var fnName = stateNames[state][1];\n  proto[fnName] = resolver(state, false, fnName);\n  proto[fnName + 'With'] = resolver(state, true, fnName);\n});\n\nvar WBDeferred = WBClass.extend(proto);\nmodule.exports = WBDeferred;\n",
    "'use strict';\n\nvar WBEventEmitter = require('./WBClass').extend({\n  'mixins': [\n    require('./mixins/WBBindableMixin'),\n    require('./mixins/WBEventsMixin')\n  ]\n});\n\nmodule.exports = WBEventEmitter;\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar clone = require('./lib/clone');\nvar assert = require('./lib/assert');\nvar WBSingleton = require('./WBSingleton');\n\nvar WBMixin = WBSingleton.extend({\n\n  // Apply the mixin to an instance of a class\n  'applyTo': function (instance) {\n\n    var behavior = clone(this.Behavior, true);\n\n    // apply mixin's initialize & remove it from the instance\n    var initializer;\n    if (typeof behavior.initialize === 'function') {\n      initializer = behavior.initialize;\n      delete behavior.initialize;\n    }\n\n    // augment mixin's properties object into the instance\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // mixin the behavior\n    extend(instance, behavior);\n\n    // apply the initializer, if any\n    initializer && initializer.apply(instance);\n\n    // augment proerties to the instance\n    properties && extend(instance, properties);\n\n    return instance;\n  },\n\n  // Apply the mixin to the class directly\n  'applyToClass': function (klass) {\n\n    // validate class\n    assert.class(klass, 'applyToClass expects a class');\n\n    var proto = klass.prototype;\n    var behavior = clone(this.Behavior, true);\n\n    // cache the mixin's initializer, to be applied later\n    var initialize = behavior.initialize;\n    if (typeof initialize === 'function') {\n      (!proto.hasOwnProperty('initializers')) && (proto.initializers = []);\n      proto.initializers.push(initialize);\n      delete behavior.initialize;\n    }\n\n    var properties = behavior.properties;\n    delete behavior.properties;\n\n    // extend the prototype\n    extend(proto, behavior);\n\n    // cache the properties, to be applied later\n    (!proto.hasOwnProperty('properties')) && (proto.properties = {});\n    properties && extend(proto.properties, properties);\n\n    return klass;\n  }\n});\n\n// The only real change from a simple singleton is\n// the altered extend class method, which will save\n// \"mixinProps\" into a specific member, for easy\n// and clean application using #applyTo\nWBMixin.extend = function (mixinProps, staticProps) {\n\n  mixinProps || (mixinProps = {});\n  staticProps || (staticProps = {});\n\n  var current = clone(this.Behavior, true);\n  staticProps.Behavior = extend(current, mixinProps);\n  var mixin = WBSingleton.extend.call(this, staticProps);\n\n  mixin.extend = WBMixin.extend;\n\n  return mixin;\n};\n\nmodule.exports = WBMixin;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nfunction proxy (name) {\n  return function () {\n    var deferred = this.deferred;\n    deferred[name].apply(deferred, arguments);\n    return this;\n  };\n}\n\nvar proto = {\n  'constructor': function (deferred) {\n    this.deferred = deferred;\n  },\n\n  'promise': function () {\n    return this;\n  },\n\n  'state': function () {\n    return this.deferred.state();\n  }\n};\n\n[\n  'done',\n  'fail',\n  'then'\n].forEach(function (name) {\n  proto[name] = proxy(name);\n});\n\nproto.always = proto.then;\n\nmodule.exports = WBClass.extend(proto);\n",
    "'use strict';\n\nvar extend = require('./lib/extend');\nvar createUID = require('./lib/createUID');\n\nfunction applyMixins (mixins, instance) {\n  var mixin;\n  while (mixins.length) {\n    mixin = mixins.shift();\n    (typeof mixin.applyTo === 'function') &&\n      mixin.applyTo(instance);\n  }\n}\n\nfunction extendSelf (staticProps) {\n  /* jshint validthis:true */\n\n  staticProps = staticProps || {};\n\n  // extend from the base singleton\n  var BaseSingleton = this || WBSingleton;\n\n  // create a new instance\n  Ctor.prototype = BaseSingleton;\n  var singleton = new Ctor();\n\n  // extract mixins\n  var mixins = staticProps.mixins || [];\n  staticProps.mixins = undefined;\n\n  // apply mixins to the instance\n  applyMixins(mixins, singleton);\n\n  // append the static properties to the singleton\n  extend(singleton, staticProps);\n\n  // make the singleton extendable\n  // Do this after applying mixins,\n  // to ensure that no mixin can override `extend` method\n  singleton.extend = extendSelf;\n\n  // every signleton gets a UID\n  singleton.uid = createUID();\n\n  return singleton;\n}\n\nvar Ctor = function () {};\nCtor.prototype = {\n  'extend': extendSelf\n};\n\nvar WBSingleton = new Ctor();\nmodule.exports = WBSingleton;\n",
    "'use strict';\n\nvar WBClass = require('./WBClass');\n\nvar WBDestroyableMixin = require('./mixins/WBDestroyableMixin');\nvar originalDestroy = WBDestroyableMixin.Behavior.destroy;\n\nvar WBStateModel = WBClass.extend({\n\n  'mixins': [\n    require('./mixins/WBEventsMixin'),\n    require('./mixins/WBStateMixin'),\n    require('./mixins/WBBindableMixin'),\n    WBDestroyableMixin\n  ],\n\n  'initialize': function (attributes) {\n\n    var self = this;\n\n    if (attributes) {\n      self.attributes = attributes;\n    }\n  },\n\n  'sync':  function (method, instance, options) {\n    if (options && typeof options.success === 'function') {\n      options.success();\n    }\n  },\n\n  'fetch': function (options) {\n    var self = this;\n    var success = options.success;\n    var model = this;\n    options.success = function (resp) {\n      if (!model.set(resp, options)) return false;\n      if (success) success(model, resp, options);\n      model.trigger('sync', model, resp, options);\n    };\n    return self.sync('read', self, options);\n  },\n\n  'save': function (key, val, options) {\n\n    var self = this;\n    if (!self.destroying) {\n      // set the attributes\n      self.set(key, val, options);\n      // sync\n      (typeof key === 'object') && (options = val);\n      self.sync('update', self, options);\n    }\n    return self;\n  },\n\n  'destroy': function (options) {\n\n    var self = this;\n    if (!self.destroying) {\n      self.destroying = true;\n      originalDestroy.call(self, options);\n      self.attributes = {};\n      self.sync('delete', self, options);\n    }\n  }\n});\n\nmodule.exports = WBStateModel;\n",
    "'use strict';\n\nmodule.exports = {\n  'lib': require('./lib'),\n  'BaseEventEmitter': require('./BaseEventEmitter'),\n  'BaseSingleton': require('./BaseSingleton'),\n  'WBClass': require('./WBClass'),\n  'WBDeferred': require('./WBDeferred'),\n  'WBEventEmitter': require('./WBEventEmitter'),\n  'WBMixin': require('./WBMixin'),\n  'WBSingleton': require('./WBSingleton'),\n  'WBStateModel': require('./WBStateModel'),\n  'mixins': require('./mixins')\n};\n",
    "'use strict';\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || '');\n  }\n}\n\nvar nativeIsArray = Array.isArray;\nassert.empty = function (object, message) {\n  var keys = nativeIsArray(object) ? object : Object.keys(object);\n  assert(keys.length === 0, message);\n};\n\nassert.array = function (array, message) {\n  assert(nativeIsArray(array), message);\n};\n\nassert.class = function (klass, message) {\n  var proto = klass.prototype;\n  assert(proto && proto.constructor === klass, message);\n};\n\nassert.number = function (value, message) {\n  assert(typeof value === 'number' && !isNaN(value), message);\n};\n\nvar types = [\n  'undefined',\n  'boolean',\n  'string',\n  'function',\n  'object'\n];\n\nfunction typecheck (type) {\n  assert[type] = function (o, message) {\n    assert(typeof o === type, message);\n  };\n}\n\nwhile (types.length) {\n  typecheck(types.shift());\n}\n\nmodule.exports = assert;\n",
    "'use strict';\n\nvar nativeIsArray = Array.isArray;\n\nfunction cloneArray (arr, isDeep) {\n  arr = arr.slice();\n  if (isDeep) {\n    var newArr = [], value;\n    while (arr.length) {\n      value = arr.shift();\n      value = (value instanceof Object) ? clone(value, isDeep) : value;\n      newArr.push(value);\n    }\n    arr = newArr;\n  }\n  return arr;\n}\n\nfunction cloneDate (date) {\n  return new Date(date.getTime());\n}\n\nfunction cloneObject (source, isDeep) {\n  var object = {};\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var value = source[key];\n      if (value instanceof Date) {\n        object[key] = cloneDate(value);\n      } else if (typeof value === 'object' && value !== null && isDeep) {\n        object[key] = clone(value, isDeep);\n      } else {\n        object[key] = value;\n      }\n    }\n  }\n  return object;\n}\n\nfunction clone (obj, isDeep) {\n\n  if (nativeIsArray(obj)) {\n    return cloneArray(obj, isDeep);\n  }\n\n  return cloneObject(obj, isDeep);\n}\n\nmodule.exports = clone;\n",
    "// http://stackoverflow.com/a/21963136/933653\n'use strict';\n\nvar ff = 0xff;\nvar lut = [];\nfor (var i = 0; i < 256; i++) {\n  lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nvar random = Math.random;\nfunction randHex() {\n  return (random() * 0xffffffff | 0);\n}\n\nfunction section0 () {\n  var d0 = randHex();\n  return lut[d0 & ff] + lut[d0 >> 8 & ff] +\n           lut[d0 >> 16 & ff] + lut[d0 >> 24 & ff];\n}\n\nfunction section1 () {\n  var d1 = randHex();\n  return lut[d1 & ff] + lut[d1 >> 8 & ff] + '-' +\n         lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & ff];\n}\n\nfunction section2 () {\n  var d2 = randHex();\n  return lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & ff] + '-' +\n       lut[d2 >> 16 & ff] + lut[d2 >> 24 & ff];\n}\n\nfunction section3 () {\n  var d3 = randHex();\n  return lut[d3 & ff] + lut[d3 >> 8 & ff] +\n       lut[d3 >> 16 & ff] + lut[d3 >> 24 & ff];\n}\n\nfunction createUID (prefix) {\n  var uid = [section0(), section1(), section2(), section3()].join('-');\n  return (!prefix ? '' : prefix).toString() + uid;\n}\n\nmodule.exports = createUID;\n",
    "'use strict';\n\n// Returns a function, that, as long as it continues to be invoked, will not\n// be triggered. The function will be called after it stops being called for\n// N milliseconds. If `immediate` is passed, trigger the function on the\n// leading edge, instead of the trailing.\n// From: http://davidwalsh.name/function-debounce\nfunction debounce (fn, wait, immediate) {\n  var timeout;\n  return function() {\n    var context = this, args = arguments;\n    var later = function() {\n      timeout = null;\n      if (!immediate) {\n        fn.apply(context, args);\n      }\n    };\n    var callNow = immediate && !timeout;\n    clearTimeout(timeout);\n    timeout = setTimeout(later, wait);\n    if (callNow) {\n      fn.apply(context, args);\n    }\n  };\n}\n\nmodule.exports = debounce;",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar delay = require('./delay');\n\nfunction defer (fn) {\n  var args = toArray(arguments);\n  args[0] = 1;\n  args.unshift(fn);\n  return delay.apply(null, args);\n}\n\nmodule.exports = defer;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction delay (fn, time, context) {\n  var args = toArray(arguments, 3);\n  return setTimeout(function () {\n\n    var destroyed = context && context.destroyed;\n    !destroyed && fn.apply(context, args);\n  }, time);\n}\n\nmodule.exports = delay;\n",
    "'use strict';\n\nvar assert = require('./assert');\nvar toArray = require('./toArray');\nvar clone = require('./clone');\n\nvar eventSplitter = /\\s+/;\n\nvar validationErrors = {\n  'trigger': 'Cannot trigger event(s) without event name(s)',\n  'events': 'Cannot bind/unbind without valid event name(s)',\n  'callback': 'Cannot bind/unbind to an event without valid callback function'\n};\n\nvar events = {\n\n  'properties': {\n    '_events': {},\n    '_cache': {}\n  },\n\n  'on': function (events, callback, context) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.events);\n    assert.function(callback, validationErrors.callback);\n\n    // loop through the events & bind them\n    self.iterate(events, function (name) {\n      // keep the binding\n      self.bind(name, callback, context);\n\n      // if this was a published event, do an immediate trigger\n      var cache = self._cache;\n      if (cache[name]) {\n        callback.apply(context || self, cache[name]);\n      }\n    });\n\n    return self;\n  },\n\n  'off': function (events, callback, context) {\n\n    var self = this;\n\n    // validate events only if a truthy value is passed\n    events && assert.string(events, validationErrors.events);\n\n    // if no arguments were passed, unbind everything\n    if (!events && !callback && !context) {\n      self._events = {};\n      return self;\n    }\n\n    // if no events are passed, unbind all events with this callback\n    var localEvents = events || Object.keys(self._events);\n\n    // loop through the events & bind them\n    self.iterate(localEvents, function (name) {\n      self.unbind(name, callback, context);\n    });\n\n    return self;\n  },\n\n  'once': function (events, callback, context) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // create a one time binding\n    args[1] = function () {\n      self.off.apply(self, args);\n      callback.apply(context || self, arguments);\n    };\n\n    self.on.apply(self, args);\n\n    return self;\n  },\n\n  'publish': function (events) {\n\n    var self = this;\n    var args = toArray(arguments);\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    self.iterate(events, function (name) {\n      var cache = self._cache;\n      if (!cache[name]) {\n        cache[name] = args.slice(1);\n        args[0] = name;\n        self.trigger.apply(self, args);\n      }\n    });\n\n    return self;\n  },\n\n  'unpublish': function (events) {\n\n    var self = this;\n\n    // validate events\n    assert.string(events, validationErrors.events);\n\n    // remove the cache for the events\n    self.iterate(events, function (name) {\n      self._cache[name] = undefined;\n    });\n\n    return self;\n  },\n\n  'unpublishAll': function () {\n    var self = this;\n    self._cache = {};\n    return self;\n  },\n\n  'trigger': function (events) {\n\n    var self = this;\n\n    // validate arguments\n    assert.string(events, validationErrors.trigger);\n\n    // loop through the events & trigger them\n    var params = toArray(arguments, 1);\n    self.iterate(events, function (name) {\n      self.triggerEvent(name, params);\n    });\n\n    return self;\n  },\n\n  'triggerEvent': function (name, params) {\n\n    var self = this;\n    var events = self._events || {};\n\n    // call sub-event handlers\n    var current = [];\n    var fragments = name.split(':');\n    var subName;\n    while (fragments.length) {\n      current.push(fragments.shift());\n      subName = current.join(':');\n      if (subName in events) {\n        self.triggerSection(subName, fragments, params);\n      }\n    }\n  },\n\n  'triggerSection': function (name, fragments, params) {\n\n    var self = this;\n    var events = self._events || {};\n    var bucket = events[name] || [];\n\n    bucket.forEach(function (item) {\n      var args;\n      if (fragments.length) {\n        args = clone(params);\n        args.unshift(fragments);\n      }\n      item.callback.apply(item.context || self, args || params);\n    });\n  },\n\n  'iterate': function (events, iterator) {\n\n    var self = this;\n    var localEvents = events;\n\n    if (typeof localEvents === 'string') {\n      localEvents = localEvents.split(eventSplitter);\n    } else {\n      assert.array(localEvents);\n    }\n\n    while (localEvents.length) {\n      iterator.call(self, localEvents.shift());\n    }\n  },\n\n  'bind': function (name, callback, context) {\n\n    var self = this;\n\n    // store the reference to the callback + context\n    var events = self._events || {};\n    var bucket = events[name] || (events[name] = []);\n    bucket.push({\n      'callback': callback,\n      'context': context\n    });\n\n    return self;\n  },\n\n  'unbind': function (name, callback, context) {\n\n    var self = this;\n\n    // lookup the reference to handler & remove it\n    var events = self._events;\n    var bucket = events[name] || [];\n    var retain = [];\n\n    // loop through the handlers\n    var i = -1, l = bucket.length, item;\n    while (++i < l) {\n      item = bucket[i];\n      if ((callback && callback !== item.callback) ||\n          (context && context !== item.context)) {\n        retain.push(item);\n      }\n    }\n\n    // flush out detached handlers\n    events[name] = retain;\n\n    return self;\n  }\n};\n\nmodule.exports = events;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\nvar merge = require('./merge');\nvar assert = require('./assert');\n\nfunction extend () {\n\n  // convert the argument list into an array\n  var args = toArray(arguments);\n\n  // validate input\n  assert(args.length > 0, 'extend expect one or more objects');\n\n  // loop through the arguments\n  // & merging them recursively\n  var object = args.shift();\n  while (args.length) {\n    merge(object, args.shift());\n  }\n\n  return object;\n}\n\nmodule.exports = extend;\n",
    "'use strict';\n\nfunction forArray (array, iterator, context) {\n  for (var i = 0, l = array.length; i < l; i++) {\n    if (iterator.call(context, array[i], i, array) === false) {\n      return;\n    }\n  }\n}\n\nfunction forObject (object, iterator, context) {\n  for (var key in object) {\n    if (object.hasOwnProperty(key)) {\n      if (iterator.call(context, object[key], key) === false) {\n        return;\n      }\n    }\n  }\n}\n\nfunction forEach (collection, iterator, context) {\n  var handler = Array.isArray(collection) ? forArray : forObject;\n  handler(collection, iterator, context);\n}\n\nmodule.exports = forEach;\n",
    "'use strict';\n\nvar merge = require('./merge');\nvar extend = require('./extend');\n\nfunction mergeFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = {};\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = merge(mergeFromSuper(_super, key), baseData);\n  }\n\n  return extend({}, baseData);\n}\n\nfunction concatFromSuper (instance, key) {\n\n  var constructor = instance.constructor;\n  var proto = constructor.prototype;\n\n  var baseData = [];\n  if (instance.hasOwnProperty(key)) {\n    baseData = instance[key];\n  } else if (proto.hasOwnProperty(key)) {\n    baseData = proto[key];\n  }\n\n  var _super = constructor && constructor.__super__;\n  if (_super) {\n    baseData = [].concat(concatFromSuper(_super, key), baseData);\n  }\n\n  return [].concat(baseData);\n}\n\nmodule.exports = {\n  'merge': mergeFromSuper,\n  'concat': concatFromSuper\n};\n",
    "'use strict';\n\nfunction functions (obj) {\n  var funcs = [];\n  for (var key in obj) {\n    if (typeof obj[key] === 'function') {\n      funcs.push(key);\n    }\n  }\n  return funcs;\n}\n\nmodule.exports = functions;\n",
    "'use strict';\n\nmodule.exports = {\n  'assert': require('./assert'),\n  'clone': require('./clone'),\n  'createUID': require('./createUID'),\n  'debounce': require('./debounce'),\n  'defer': require('./defer'),\n  'delay': require('./delay'),\n  'events': require('./events'),\n  'extend': require('./extend'),\n  'forEach': require('./forEach'),\n  'fromSuper': require('./fromSuper'),\n  'functions': require('./functions'),\n  'inherits': require('./inherits'),\n  'isEqual': require('./isEqual'),\n  'merge': require('./merge'),\n  'size': require('./size'),\n  'toArray': require('./toArray'),\n  'when': require('./when'),\n  'where': require('./where')\n};",
    "'use strict';\n\nvar extend = require('./extend');\n\n// Helper function to correctly set up the prototype chain, for subclasses.\n// Similar to `goog.inherits`, but uses a hash of prototype properties and\n// class properties to be extended.\nfunction inherits (parent, protoProps, staticProps) {\n\n  var child;\n\n  // The constructor function for the new subclass is either defined by you\n  // (the \"constructor\" property in your `extend` definition), or defaulted\n  // by us to simply call `super()`.\n  if (protoProps && protoProps.hasOwnProperty('constructor')) {\n    child = protoProps.constructor;\n  }\n  else {\n    child = function () {\n      return parent.apply(this, arguments);\n    };\n  }\n\n  // Inherit class (static) properties from parent.\n  extend(child, parent);\n\n  // Set the prototype chain to inherit from `parent`, without calling\n  // `parent`'s constructor function.\n  child.prototype = Object.create(parent.prototype);\n\n  // Add prototype properties (instance properties) to the subclass,\n  // if supplied.\n  extend(child.prototype, protoProps);\n\n  // Correctly set child's `prototype.constructor`.\n  child.prototype.constructor = child;\n\n  // Add static properties to the constructor function, if supplied.\n  extend(child, staticProps);\n\n  // Set a convenience property\n  // in case the parent's prototype is needed later.\n  child.__super__ = parent.prototype;\n\n  return child;\n}\n\nmodule.exports = inherits;\n",
    "'use strict';\n\n// TODO: implement deepEqual\nfunction isEqual (a, b) {\n  return a === b;\n}\n\nmodule.exports = isEqual;\n",
    "'use strict';\n\nvar toArray = require('./toArray');\n\nfunction merge (object) {\n  var localSource;\n  var sources = toArray(arguments, 1);\n  while (sources.length) {\n    localSource = sources.shift();\n    for (var key in localSource) {\n      if (localSource.hasOwnProperty(key)) {\n        object[key] = localSource[key];\n      }\n    }\n  }\n  return object;\n}\n\nmodule.exports = merge;\n",
    "'use strict';\n\nfunction size (collection) {\n  !Array.isArray(collection) && (collection = Object.keys(collection));\n  return collection.length;\n}\n\nmodule.exports = size;\n",
    "'use strict';\n\nfunction getAllocatedArray (arrLength) {\n\n  arrLength = arrLength > 0 ? arrLength : 0;\n  return new Array(arrLength);\n}\n\nfunction toArray (arrayLikeObj, skip) {\n\n  var localSkip = skip || 0;\n  var length = arrayLikeObj.length;\n  var arr = getAllocatedArray(length - localSkip);\n\n  for (var i = localSkip; i < length; i++) {\n    arr[i - localSkip] = arrayLikeObj[i];\n  }\n\n  return arr;\n}\n\nmodule.exports = toArray;",
    "'use strict';\n\nvar WBDeferred = require('../WBDeferred');\nvar toArray = require('./toArray');\n\nfunction When () {\n\n  var context = this;\n  var main = new WBDeferred(context);\n  var deferreds = toArray(arguments);\n\n  // support passing an array of deferreds, to avoid `apply`\n  if (deferreds.length === 1 && Array.isArray(deferreds[0])) {\n    deferreds = deferreds[0];\n  }\n\n  var count = deferreds.length;\n  var args = new Array(count);\n\n  function Fail () {\n    main.rejectWith(this);\n  }\n\n  function Done () {\n\n    if (main.state() === 'rejected') {\n      return;\n    }\n\n    var index = count - deferreds.length - 1;\n    args[index] = toArray(arguments);\n\n    if (deferreds.length) {\n      var next = deferreds.shift();\n      next.done(Done);\n    } else {\n      args.unshift(this);\n      main.resolveWith.apply(main, args);\n    }\n  }\n\n  if (deferreds.length) {\n\n    deferreds.forEach(function (deferred) {\n      deferred.fail(Fail);\n    });\n\n    var current = deferreds.shift();\n    current.done(Done);\n  } else {\n    main.resolve();\n  }\n\n  return main.promise();\n}\n\nmodule.exports = When;\n",
    "'use strict';\n\nvar forEach = require('./forEach');\n\nfunction where (collection, properties) {\n  var matches = [];\n  forEach(collection, function (item) {\n    for (var key in properties) {\n      if (item[key] !== properties[key]) {\n        return;\n      }\n      matches.push(item);\n    }\n  });\n  return matches;\n}\n\nmodule.exports = where;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\n\nvar ControllableMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    self.controllers = [];\n    self.implemented = [];\n\n    self.implements = fromSuper.concat(self, 'implements');\n    self.createControllerInstances();\n\n    self.bindOnceTo(self, 'destroy', 'destroyControllers');\n  },\n\n  'createControllerInstances': function () {\n\n    var self = this;\n\n    var Controllers = self.implements;\n    if (typeof Controllers === 'function') {\n      Controllers = Controllers.call(self);\n    }\n\n    var ControllerClass, controllerInstance, i;\n\n    // the order in which the controllers are implemented is important!\n    for (i = Controllers.length; i--;) {\n      ControllerClass = Controllers[i];\n\n      // If we have already implemented a controller that inherits from\n      // this controller, we don't need another one...\n      if (self.implemented.indexOf(ControllerClass.toString()) < 0) {\n\n        controllerInstance = new ControllerClass(self);\n        self.controllers.push(controllerInstance);\n        controllerInstance.parent = self;\n\n        self.trackImplementedSuperConstructors(ControllerClass);\n      }\n    }\n\n    return self.implemented;\n  },\n\n  'trackImplementedSuperConstructors': function (Controller) {\n\n    var self = this;\n    var _super = Controller.__super__;\n    var superConstructor = _super && _super.constructor;\n\n    if (superConstructor) {\n      self.implemented.push(superConstructor.toString());\n      self.trackImplementedSuperConstructors(superConstructor);\n    }\n  },\n\n  'destroyControllers': function () {\n\n    var self = this;\n\n    // Loop and destroy\n    var controller;\n    var controllers = self.controllers;\n\n    while (controllers.length) {\n      // A controller can exist multiple times in the list,\n      // since it's based on the event name,\n      // so make sure to only destroy each one once\n      controller = controllers.shift();\n      controller.destroyed || controller.destroy();\n    }\n  }\n});\n\nmodule.exports = ControllableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar fromSuper = require('../lib/fromSuper');\nvar clone = require('../lib/clone');\n\nvar ObservableHashMixin = WBMixin.extend({\n\n  'initialize': function () {\n\n    var self = this;\n\n    var observesHash = fromSuper.merge(self, 'observes');\n    for (var target in observesHash) {\n      self.bindToTarget(self.resolveTarget(target), observesHash[target]);\n    }\n  },\n\n  'bindToTarget': function (target, events) {\n\n    var self = this;\n\n    for (var eventString in events) {\n      self.bindHandlers(target, eventString, events[eventString]);\n    }\n  },\n\n  'bindHandlers': function (target, eventString, handlers) {\n\n    var self = this;\n\n    if (typeof handlers === 'string') {\n      handlers = [handlers];\n    } else {\n      handlers = clone(handlers);\n    }\n\n    while (handlers.length) {\n      self.bindTo(target, eventString, handlers.shift());\n    }\n  },\n\n  'resolveTarget': function (key) {\n\n    var self = this;\n\n    // allow observing self\n    if (key === 'self') {\n      return self;\n    }\n\n    var target = self[key];\n    if (!target && typeof key === 'string' && key.indexOf('.') > -1) {\n      key = key.split('.');\n      target = self;\n      while (key.length && target) {\n        target = target[key.shift()];\n      }\n    }\n\n    return target;\n  }\n\n});\n\nmodule.exports = ObservableHashMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar createUID = require('../lib/createUID');\n\nvar WBBindableMixin = WBMixin.extend({\n\n  'properties': {\n    '_bindings': {},\n    '_namedEvents': {}\n  },\n\n  // keeps callback closure in own execution context with\n  // only callback and context\n  'callbackFactory': function  (callback, context) {\n\n    var self = this;\n    var bindCallback;\n\n    if (typeof callback === 'string') {\n      bindCallback = self.stringCallbackFactory(callback, context);\n    }\n    else {\n      bindCallback = self.functionCallbackFactory(callback, context);\n    }\n\n    return bindCallback;\n  },\n\n  'stringCallbackFactory': function (callback, context) {\n\n    return function stringCallback () {\n      context[callback].apply(context, arguments);\n    };\n  },\n\n  'functionCallbackFactory': function (callback, context) {\n\n    return function functionCallback () {\n      callback.apply(context, arguments);\n    };\n  },\n\n  'bindTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    // default to self if context not provided\n    var ctx = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, ctx);\n    if (bound) {\n      return bound;\n    }\n\n    var callbackFunc, args;\n    // if a jquery object\n    if (self.isTargetJquery(target)) {\n      // jquery does not take context in .on()\n      // cannot assume on takes context as a param for bindable object\n      // create a callback which will apply the original callback\n      // in the correct context\n      callbackFunc = self.callbackFactory(callback, ctx);\n      args = [event, callbackFunc];\n    }\n    else {\n      // Backbone accepts context when binding, simply pass it on\n      callbackFunc = (typeof callback === 'string') ? ctx[callback] : callback;\n      args = [event, callbackFunc, ctx];\n    }\n\n    // create binding on target\n    target.on.apply(target, args);\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': callbackFunc,\n      'context': ctx\n    };\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'isTargetJquery': function (target) {\n\n    var constructor = target.constructor;\n    return constructor && constructor.fn && constructor.fn.on === target.on;\n  },\n\n  'bindOnceTo': function (target, event, callback, context) {\n\n    var self = this;\n    self.checkBindingArgs.apply(self, arguments);\n\n    context = context || self;\n\n    // if this binding already made, return it\n    var bound = self.isAlreadyBound(target, event, callback, context);\n    if (bound) {\n      return bound;\n    }\n\n    // this is a wrapper\n    var onceBinding = function () {\n\n      ((typeof callback === 'string') ? context[callback] : callback).apply(context, arguments);\n      self.unbindFrom(binding);\n    };\n\n    var binding = {\n      'uid': createUID(),\n      'target': target,\n      'event': event,\n      'originalCallback': callback,\n      'callback': onceBinding,\n      'context': context\n    };\n\n    target.on(event, onceBinding, context);\n\n    self._bindings[binding.uid] = binding;\n    self.addToNamedBindings(event, binding);\n\n    return binding;\n  },\n\n  'unbindFrom': function (binding) {\n\n    var self = this;\n\n    var uid = binding && binding.uid;\n    if (!binding || (typeof uid !== 'string')) {\n      throw new Error('Cannot unbind from undefined or invalid binding');\n    }\n\n    var event = binding.event;\n    var context = binding.context;\n    var callback = binding.callback;\n    var target = binding.target;\n\n    // a binding object with only uid, i.e. a destroyed/unbound\n    // binding object has been passed - just do nothing\n    if (!event || !callback || !target || !context) {\n      return;\n    }\n\n    target.off(event, callback, context);\n\n    // clean up binding object, but keep uid to\n    // make sure old bindings, that have already been\n    // cleaned, are still recognized as bindings\n    for (var key in binding) {\n      if (key !== 'uid') {\n        delete binding[key];\n      }\n    }\n\n    delete self._bindings[uid];\n\n    var namedEvents = self._namedEvents;\n    var events = namedEvents[event];\n\n    if (events) {\n      var cloned = events && events.slice(0);\n      for (var i = events.length - 1; i >= 0; i--) {\n        if (events[i].uid === uid) {\n          cloned.splice(i, 1);\n        }\n      }\n\n      namedEvents[event] = cloned;\n    }\n\n    return;\n  },\n\n  'unbindFromTarget': function (target) {\n\n    var self = this;\n\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot unbind from undefined or invalid binding target');\n    }\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      if (binding.target === target) {\n        self.unbindFrom(binding);\n      }\n    }\n  },\n\n  'unbindAll': function () {\n\n    var self = this;\n\n    var binding;\n    for (var key in self._bindings) {\n      binding = self._bindings[key];\n      self.unbindFrom(binding);\n    }\n  },\n\n  'checkBindingArgs': function (target, event, callback, context) {\n\n    context = context || this;\n\n    // do not change these messages without updating the specs\n    if (!target || (typeof target.on !== 'function')) {\n      throw new Error('Cannot bind to undefined target or target without #on method');\n    }\n\n    if (!event || (typeof event !== 'string')) {\n      throw new Error('Cannot bind to target event without event name');\n    }\n\n    if (!callback || ((typeof callback !== 'function') && (typeof callback !== 'string'))) {\n      throw new Error('Cannot bind to target event without a function or method name as callback');\n    }\n\n    if ((typeof callback === 'string') && !context[callback]) {\n      throw new Error('Cannot bind to target using a method name that does not exist for the context');\n    }\n  },\n\n  'isAlreadyBound': function (target, event, callback, context) {\n\n    var self = this;\n    // check for same callback on the same target instance\n    // return early withthe event binding\n    var events = self._namedEvents[event];\n    if (events) {\n      for (var i = 0, max = events.length; i < max; i++) {\n\n        var current = events[i] || {};\n\n        // the below !boundTarget check seems unreachable\n        // was added in this commit of the web app: c75d5077c0a8629b60cb6dd1cd78d3bc77fcac48\n        // need to ask Adam under what conditions this would be possible\n        var boundTarget = current.target;\n        if (!boundTarget) {\n          return false;\n        }\n\n        var targetBound = target.uid ? target.uid === boundTarget.uid : false;\n        if (current.originalCallback === callback &&\n            current.context === context && targetBound) {\n          return current;\n        }\n      }\n    }\n\n    return false;\n  },\n\n  'addToNamedBindings': function (event, binding) {\n\n    var self = this;\n    if (!self._namedEvents[event]) {\n      self._namedEvents[event] = [];\n    }\n    self._namedEvents[event].push(binding);\n  }\n});\n\nmodule.exports = WBBindableMixin;\n",
    "'use strict';\n\nvar forEach = require('../lib/forEach');\nvar WBMixin = require('../WBMixin');\n\nfunction noop () {}\n\nfunction Call (fn) {\n  var self = this;\n  (typeof fn === 'string') && (fn = self[fn]);\n  (typeof fn === 'function') && fn.call(self);\n}\n\nvar cleanupMethods = ['unbind', 'unbindAll', 'onDestroy'];\n\nvar WBDestroyableMixin = WBMixin.extend({\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.trigger('destroy');\n\n    // clean up\n    forEach(cleanupMethods, Call, self);\n\n    self.destroyObject(self);\n\n    self.destroyed = true;\n  },\n\n  'destroyObject': function (object) {\n\n    var self = this;\n    for (var key in object) {\n      self.destroyKey(key, object);\n    }\n  },\n\n  'destroyKey': function (key, context) {\n\n    if (context.hasOwnProperty(key) && key !== 'uid' && key !== 'cid') {\n      // make functions noop\n      if (typeof context[key] === 'function') {\n        context[key] = noop;\n      }\n      // and others undefined\n      else {\n        context[key] = undefined;\n      }\n    }\n  }\n});\n\nmodule.exports = WBDestroyableMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar events = require('../lib/events');\n\nvar WBEventsMixin = WBMixin.extend(events);\n\nmodule.exports = WBEventsMixin;\n",
    "'use strict';\n\nvar clone = require('../lib/clone');\nvar merge = require('../lib/merge');\nvar extend = require('../lib/extend');\nvar isEqual = require('../lib/isEqual');\nvar WBMixin = require('../WBMixin');\n\nvar WBStateMixin = WBMixin.extend({\n\n  'attributes': {},\n  'options': {},\n\n  'initialize': function (attributes, options) {\n\n    var self = this;\n    self.attributes = extend({}, self.defaults, attributes);\n    self.options = options || {};\n    self.changed = {};\n  },\n\n  'get': function (key) {\n    console.warn('getters are deprecated');\n    return this.attributes[key];\n  },\n\n  'set': function (key, val, options) {\n\n    var self = this;\n    if (key === null) {\n      return self;\n    }\n\n    var attrs, attr;\n    // Handle both `\"key\", value` and `{key: value}` -style arguments.\n    if (typeof key === 'object') {\n      attrs = key;\n      options = val;\n    } else {\n      attrs = {};\n      attrs[key] = val;\n    }\n\n    // default options are empty\n    options || (options = {});\n\n    // no need to track changes on options.silent\n    if (options.silent) {\n      merge(self.attributes, attr);\n    }\n    // For each `set` attribute, update or delete the current value.\n    else {\n      var changes = self.changes(attrs, options);\n      self._trigger(attrs, changes, options);\n    }\n\n    return self;\n  },\n\n  'unset': function (attr, options) {\n    return this.set(attr, undefined, extend({}, options, { 'unset': true }));\n  },\n\n  'clear': function (options) {\n    var self = this;\n    return self.set(self.defaults, options);\n  },\n\n  'changes': function (attrs, options) {\n\n    var self = this;\n    var key, val;\n    var changes = [];\n\n    var prev = clone(self.attributes, true);\n    var current = self.attributes;\n    self.changed = {};\n\n    for (key in attrs) {\n      val = attrs[key];\n      if (!isEqual(current[key], val)) {\n        changes.push(key);\n      }\n      if (!isEqual(prev[key], val)) {\n        self.changed[key] = val;\n      } else {\n        delete self.changed[key];\n      }\n\n      current[key] = options.unset ? undefined : val;\n    }\n\n    return changes;\n  },\n\n  '_trigger': function (attrs, changes, options) {\n\n    var self = this;\n    var current = self.attributes;\n\n    // if any changes found\n    // & if this is an EventEmitter,\n    // trigger the change events\n    var attr;\n    while (changes && changes.length && self.trigger) {\n      attr = changes.shift();\n      self.trigger('change:' + attr, self, current[attr], options);\n    }\n  }\n});\n\nmodule.exports = WBStateMixin;\n",
    "'use strict';\n\nvar WBMixin = require('../WBMixin');\nvar WBDeferred = require('../WBDeferred');\nvar when = require('../lib/when');\nvar toArray = require('../lib/toArray');\nvar forEach = require('../lib/forEach');\nvar delay = require('../lib/delay');\nvar defer = require('../lib/defer');\nvar functions = require('../lib/functions');\n\nvar WBUtilsMixin = WBMixin.extend({\n\n  'deferred': function () {\n    var self = this;\n    return new WBDeferred(self);\n  },\n\n  'when': function () {\n    var self = this;\n    return when.apply(self, arguments);\n  },\n\n  'defer': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[1] = args[1] || this;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return defer.apply(null, args);\n  },\n\n  'delay': function (fn) {\n    var self = this;\n    var args = toArray(arguments);\n    // default context to self\n    args[2] = args[2] || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (args[0] = self[fn]);\n    return delay.apply(null, args);\n  },\n\n  'forEach': function (collection, fn, context) {\n    var self = this;\n    // default context to self\n    context = context || self;\n    // support string names of functions on self\n    (typeof fn === 'string') && (fn = self[fn]);\n    forEach(collection, fn, context);\n  },\n\n  'functions': function (obj) {\n    return functions(obj || this);\n  }\n});\n\nmodule.exports = WBUtilsMixin;\n",
    "'use strict';\n\nmodule.exports = {\n  'ControllableMixin': require('./ControllableMixin'),\n  'ObservableHashMixin': require('./ObservableHashMixin'),\n  'WBBindableMixin': require('./WBBindableMixin'),\n  'WBDestroyableMixin': require('./WBDestroyableMixin'),\n  'WBEventsMixin': require('./WBEventsMixin'),\n  'WBStateMixin': require('./WBStateMixin'),\n  'WBUtilsMixin': require('./WBUtilsMixin')\n};",
    "'use strict';\n\n/**\n  * Default configuration file.\n  * Overidable in SDK constructor.\n  * @module config/default\n  */\n\nmodule.exports = {\n  /**\n    * Wunderlist SDK Version\n    * @type {string}\n    */\n  'release': '0.0.0',\n\n  /**\n    * Your Client Identification Number/String\n    * @type {string}\n    */\n  'clientID': undefined,\n\n  /**\n    * WebSocket connection timeout (in ms)\n    * @type {number}\n    */\n  'webSocketTimeout': 15 * 1000,\n\n  'api': {\n    'host': 'https://a.wunderlist.com/api',\n  },\n\n  'realtime': {\n    'host': 'wss://socket.wunderlist.com:8443/api/v1/sync'\n  }\n};\n",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar _super = WBDeferred.prototype;\n\nvar RequestDeferred = WBDeferred.extend({\n\n  'properties': {\n\n    'loadDurationTime': undefined,\n    'loadStarted': false,\n    'loadStartTime': undefined,\n    'latencyTime': undefined,\n\n    'startTime': undefined,\n    'url': undefined,\n    'xhr': undefined,\n  },\n\n  'error': _super.fail\n});\n\nmodule.exports = RequestDeferred;",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar RestSocketRequestDeferred = WBDeferred.extend({\n\n  'properties': {\n    'startTime': undefined,\n    'endTime': undefined,\n    'requestID': undefined,\n    'uri': undefined\n  }\n});\n\nmodule.exports = RestSocketRequestDeferred;",
    "'use strict';\n\n/**\n  * Aopi health checker\n  * @module helpers/HealthCheck\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar IOHttp = require('../io/IO');\n\nvar networkPollTime = 15 * 1000;\n\nvar HealthCheck = WBSingleton.extend({\n\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin\n  ],\n\n  'init': function (options) {\n\n    var self = this;\n\n    self.setupIO(options.config);\n    self.startPolling();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n    self.poller && clearInterval(self.poller);\n  },\n\n  'setupIO': function (config) {\n\n    var self = this;\n\n    if (!self.io) {\n      self.io = new IOHttp({\n        'config': config\n      }).io;\n    }\n  },\n\n  'startPolling': function () {\n\n    var self = this;\n\n    self.poller && clearInterval(self.poller);\n\n    self.poller = setInterval(function () {\n\n      self.checkApiHealth();\n    }, networkPollTime);\n  },\n\n  'checkApiHealth': function () {\n\n    var self = this;\n    self.io.get('/health')\n      .done(self.onHealthy, self)\n      .fail(self.onUnhealthy, self);\n  },\n\n  'onHealthy': function () {\n\n    var self = this;\n    self.trigger('healthy');\n  },\n\n  'onUnhealthy': function () {\n\n    var self = this;\n    self.trigger('unhealthy');\n  }\n});\n\nmodule.exports = HealthCheck;\n",
    "(function (global){\n'use strict';\n\n/**\n  * Holds reference for all important analytics platform headers.\n  * @module helpers/PlatformHeaders\n  * @extends module:wunderbits.core/WBSingleton\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar navigator = global.navigator || {};\nvar nodejs = global.process || {};\nvar userAgent = navigator.userAgent || ('node ' + nodejs.version);\n\nvar PlatformHeaders = WBSingleton.extend({\n  /**\n    * Precompiled platform headers.\n    * @type {object}\n    */\n  'headers': {\n    'x-client-platform': 'web',\n    'x-client-product':  'wunderlist',\n    'x-client-product-version': null,\n    'x-client-system': userAgent,\n    'x-client-system-version': 'Standard',\n    'x-client-product-git-hash': null\n  },\n\n  'init': function (options) {\n\n    var self = this;\n\n    var config = options;\n    var headers = self.headers;\n\n    headers['x-client-product-version'] = config.release;\n\n    var gitHash = /\\[(.*)\\]/.exec(config.gitHash);\n    gitHash = gitHash && gitHash[1];\n    headers['x-client-product-git-hash'] = gitHash || 'dev';\n\n    if (config.testing) {\n      headers['x-client-testing'] = 'true';\n    }\n\n    if (config.product) {\n      headers['x-client-product'] = config.product;\n    }\n  }\n});\n\nmodule.exports = PlatformHeaders;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\n/**\n* @module helpers/URL\n* @requires module:wunderbits.core/WBSingleton\n*/\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar URLHelper = WBSingleton.extend({\n\n  /**\n    * Compiles hash of request parameters into a valid URI component\n    * @param {object} params - Hash of request parameters\n    */\n  'compileParams': function (params) {\n\n    var first = true;\n    var component = '';\n    var value;\n\n    for (var key in params) {\n      value = encodeURIComponent(params[key]);\n      component += (first ? '?' : '&') + key + '=' + encodeURIComponent(value);\n\n      if (first) {\n        first = false;\n      }\n    }\n\n    return component;\n  },\n\n  /**\n    * Helper for generating full URI from a host (with path) and a params hash.\n    * @param {string} host - Host and path part of URI\n    * @param {object} params - Hash of URI params and values.\n    */\n  'generateURI': function (host, params) {\n\n    var self = this;\n\n    return host + self.compileParams(params);\n  }\n});\n\nmodule.exports = URLHelper;\n",
    "'use strict';\n\n/**\n  * Provides http IO.\n  * @module io/IO\n  * @extends module:io/IOBase\n  * @requires module:io/IOBase\n  *\n  * @example\n  * var IOHttp = require('io/IO');\n  *\n  * var params = {\n  *   'thingID': 1345\n  * };\n  *\n  * IOHttp.get('http://www.example.com/api/endpoint', params, 'asdflkj23094802938')\n  *   .done(function (response, code) {\n  *     //...\n  *   })\n  *   .fail(function (response, code) {\n  *     //...\n  *   });\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar WBDeferred = core.WBDeferred;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar SchemaValidator = require('../validators/SchemaValidator');\nvar IOBase = require('./IOBase');\n\nvar _super = IOBase.prototype;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:IO');\n\nvar IO = IOBase.extend({\n\n  // make our rest IO evented\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin\n  ],\n\n  /**\n    * @constructor\n    * @alias module:io/IO\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.config = options.config;\n\n    // set requests hash on instance\n    self.requests = {};\n\n    // verbs are programatically built by _super.initialize\n    // need to override now\n    self.wrapVerbs();\n  },\n\n  /**\n    * Moves unwrapped http verbs to _ prefixed names and sets up\n    * wrapped unprefixed verbs that execute through #requestWrapper\n    */\n  'wrapVerbs': function () {\n\n    var self = this;\n    var io = self.io;\n    ['get', 'patch', 'post', 'put', 'delete'].forEach(function (verb) {\n      io['_' + verb] = io[verb];\n      io[verb] = self.requestWrapper.bind(self, verb);\n    });\n  },\n\n  /**\n    * Hash for tracking requests made by an instance of this class\n    * @type {object}\n    */\n  'requests': {},\n\n  /**\n    * Map of token patterns for use by routes patterns\n    */\n  'tokens': {\n    'id': '([-])?[0-9]+',\n    'version': 'v(\\\\d)+',\n    'provider': '[a-z]+'\n  },\n\n  /**\n    * Map of paths patterns that should map to the 'api' host\n    */\n  'routes': {\n    'api': []\n  },\n\n  /**\n    * Map of paths patterns that do not require authorization headers\n    */\n  'authFreeRoutes': {\n    'api': [\n      'health',\n      '{{version}}/oauth/{{provider}}/exchange',\n      '{{version}}/signup',\n      '{{version}}/authenticate',\n      '{{version}}/user/password/reset'\n    ]\n  },\n\n  // make relative URLs absolute\n  'normalizeUrl': function (url) {\n\n    var self = this;\n    return self.config.api.host + url;\n  },\n\n  /**\n    * Extend #extendHeaders to inject clientID\n    */\n  'extendHeaders': function (headers) {\n\n    var self = this;\n\n    var clientID = self.config.clientID;\n    var deviceID = self.config.deviceID;\n    var instanceID = self.config.instanceID;\n\n    clientID && (headers['x-client-id'] = clientID);\n    deviceID &&(headers['x-client-device-id'] = deviceID);\n    instanceID && (headers['x-client-instance-id'] = instanceID);\n\n    if (typeof self.config.extendHeaders === 'function') {\n      self.config.extendHeaders(headers);\n    }\n\n    return _super.extendHeaders.apply(self, arguments);\n  },\n\n  /**\n    * Adds x-access-token and x-client-id headers to api endpoints that require them.\n    * @param {object} headers - current headers for the request being constructed\n    * @param {string} url - url for the request being constructed\n    */\n  'setAuthorization': function (headers) {\n\n    var self = this;\n\n    var accessToken = self.config.accessToken;\n    accessToken && (headers['x-access-token'] = accessToken);\n  },\n\n /**\n    * Wrapper for CRUD methods to inject supplied requestID, or auto generated requestID\n    * @returns {promise} Request promise.\n    * @param {string} method - HTTP method to execute\n    * @param {string} path - URI or path to make request against\n    * @param {object} [data] - Request body or hash of key value pairs for GET params\n    * @param {string} [requestID] - User supplied requestID to be sent as a header, auto generated if omitted\n    * @param {number} [timeout] - User supplied timeout in ms\n    */\n  'requestWrapper': function (method, path, data, requestID, timeout) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n    var headers = {};\n\n    if (!requestID) {\n      requestID = self.generateUID();\n    }\n\n    self.requests[requestID] = deferred;\n\n    headers['x-client-request-id'] = requestID;\n\n    timeout = timeout ? parseInt(timeout, 10) : 60000;\n\n    self.io['_' + method](path, data, headers, timeout)\n      .done(function (response, xhr) {\n\n        if (Array.isArray(response)) {\n          response.forEach(function (item) {\n\n            if (item.type) {\n              SchemaValidator.validateData(item, item.type);\n            }\n          });\n        }\n        else if (response && response.type) {\n          SchemaValidator.validateData(response, response.type);\n        }\n\n        localConsole.log(xhr.status, path);\n\n        // make the success state exatcly match socket success\n        deferred.resolve(response, xhr.status);\n      })\n      .fail(function (response, xhr) {\n\n        localConsole.error(xhr.status, xhr.statusText, path);\n\n        // make the failure state exactly match socket failure\n        deferred.reject(response, xhr.status);\n\n        if (xhr.status === 401) {\n          /**\n            * Unauthorized event\n            * @event module:io/IO#unauthorized\n            */\n          self.trigger('unauthorized');\n        }\n      })\n      .always(function () {\n        // drop reference, but keep id in hash\n        self.requests[requestID] = undefined;\n      });\n\n    return deferred.promise();\n  },\n\n  /**\n    * Generates unique indentifiers for proxy requests.\n    * @returns {string} UID\n    */\n  'generateUID': function () {\n\n    var self = this;\n    var uid;\n\n    while (!uid || !self.isUIDValid(uid)) {\n      uid = createUID();\n    }\n\n    return uid;\n  },\n\n  /**\n    * Checks that UID is not already used by a pending known request.\n    * @param {string} uid - UID\n    * @returns {boolean} - returns TRUE iff valid\n    */\n  'isUIDValid': function (uid) {\n\n    return !(uid in this.requests);\n  },\n\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n    var request = self.requests[requestID];\n\n    localConsole.debug('cancelling request locally', requestID, 'alive?', !!request);\n\n    if (request) {\n      self.requests[requestID] = undefined;\n      var data = onlineID ? {'id': onlineID} : {};\n      data.revision = revision;\n      request.resolve(data, 200);\n    }\n  }\n});\n\nmodule.exports = IO;\n",
    "(function (global){\n'use strict';\n\n// GENERIC BASE IO CLASS\n// returns class\n\nvar core = require('wunderbits.core');\nvar WBClass = core.WBClass;\nvar WBDeferred = core.WBDeferred;\nvar assert = core.lib.assert;\nvar extend = core.lib.extend;\n\nvar AjaxTransport = require('./io/AjaxTransport');\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\n\nvar _super = WBClass.prototype;\n\nvar absoluteUrlRegexp = /^(https?:)?\\/\\//;\nvar wlURLRegexp = /^(https?:)?\\/\\/\\w+\\.wunderlist.com\\//;\n\nmodule.exports = WBClass.extend({\n\n  'initialize': function (options) {\n\n    var self = this;\n    self.config = options.config;\n\n    AjaxTransport.maxRequests = self.config.maxHttpRequests || 5;\n\n    _super.initialize.apply(self, arguments);\n\n    self.io = AjaxTransport.ajax.bind(AjaxTransport);\n\n    // create io verbs on class\n    var crudOps = ['delete', 'get', 'patch', 'post', 'put'];\n    for (var i=0, len=crudOps.length; i<len; i++) {\n      self.defineVerb(crudOps[i]);\n    }\n\n    // compile routes for faster lookup\n    self.routes = self.compileRoutes(self.routes, self.tokens);\n    self.authFreeRoutes = self.compileRoutes(self.authFreeRoutes, self.tokens);\n  },\n\n  'compileRoutes': function (routes, tokens) {\n\n    var self = this;\n\n    // no routes defined\n    if (!routes) {\n      return undefined;\n    }\n\n    function markTokens (rule) {\n      return rule.replace(/\\{\\{(\\w+)\\}\\}/g, function (match, token) {\n        return tokens[token];\n      });\n    }\n\n    var compiled = {};\n    for (var service in routes) {\n      var rules = routes[service];\n      rules = rules.map(markTokens);\n      var regexp = new RegExp('^/(' + rules.join('|') + ')(\\\\?|$)');\n      var host = self.config[service].host;\n      compiled[host] = regexp;\n    }\n\n    return compiled;\n  },\n\n  // Change relative URLs to point to the correct host\n  // extend is subclass\n  'resolveUrl': function (url) {\n\n    var self = this, resolved;\n\n    // Don't touch absolute urls\n    if (absoluteUrlRegexp.test(url)) {\n      return url;\n    }\n\n    // if a known route\n    if (self.routes) {\n      resolved = self.resolveRoute(url);\n    }\n\n    // just make the url relative to the current domain\n    if (!resolved) {\n      resolved = self.normalizeUrl(url);\n    }\n\n    return resolved;\n  },\n\n  // resolve known routes to absolute urls\n  'resolveRoute': function (route) {\n\n    var self = this;\n    for (var host in self.routes) {\n      var regexp = self.routes[host];\n      if (regexp.test(route)) {\n        return host + route;\n      }\n    }\n  },\n\n  // make relative URLs absolute\n  'normalizeUrl': function (url) {\n    var location = global.location;\n    return location.protocol + '//' + location.host + url;\n  },\n\n  // add/remove/augment headers\n  // extend in subclass\n  'extendHeaders': function (headers, url) {\n\n    var self = this;\n\n    var isAbsoluteURL = absoluteUrlRegexp.test(url);\n    var isWLUrl = !isAbsoluteURL || wlURLRegexp.test(url);\n\n    // url is used by api extendHeaders\n    headers = headers || {};\n\n    // Also add custom headers needed for client-identification\n    if (isWLUrl) {\n      extend(headers, PlatformHeaders.headers);\n    }\n\n    // skip auth headers for certain urls\n    if (self.authFreeRoutes) {\n      for (var host in self.authFreeRoutes) {\n        var regexp = self.authFreeRoutes[host];\n        if (regexp.test(url)) {\n          return headers;\n        }\n      }\n    }\n\n    // Add Auth token for relative urls that need auth\n    // Don't modify any existing auth headers\n    if (isWLUrl && !headers.Authorization) {\n      self.setAuthorization(headers, url);\n    }\n\n    return headers;\n  },\n\n  'setAuthorization': function () {\n    // base class, does nothing\n  },\n\n  // Create functions for http verbs\n  'defineVerb': function (type) {\n\n    var self = this;\n\n    self.io[type] = function (url, data, headers, timeout, context) {\n\n      assert(url, 'need a url for ajax calls');\n\n      headers = headers || {};\n      headers = self.extendHeaders(headers, url);\n\n      var deferred = new WBDeferred();\n      var promise = deferred.promise();\n\n      // resolve the url to an absolute url\n      url = self.resolveUrl(url);\n\n      // format the data\n      if (typeof data === 'object') {\n        // convert to query params for get requests\n        if (type === 'get') {\n          var params = [], key;\n          for (key in data) {\n            params.push(key + '=' + encodeURIComponent(data[key]));\n          }\n          params.length && (url = url + '?' + params.join('&'));\n          data = undefined;\n        }\n        // for other methods, Serialize the data as json\n        else {\n          data = JSON.stringify(data);\n        }\n      }\n\n      // send the request\n      self.io(url, {\n        'type': type.toUpperCase(),\n        'data': data,\n        'headers': headers,\n        'success': deferred.resolve.bind(deferred),\n        'error': deferred.reject.bind(deferred),\n        'timeout': timeout,\n        'context': context\n      });\n\n      return promise;\n    };\n  }\n});\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\n/**\n  * @module io/RestSocket\n  * @requires module:io/io/WebSocket\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/lib/SafeParse\n  * @requires module:wunderbits.core/lib/createUID\n  * @extends module:wunderbites/WBEventEmitter\n  *\n  * @example\n  * var IORestSocket = require('io/RestSocket');\n  *\n  * var params = {\n  *   'thingID': 1345\n  * };\n  *\n  * IORestSocket.get('http://www.example.com/api/endpoint', params, 'asdflkj23094802938')\n  *   .done(function (response, code) {\n  *     //...\n  *   })\n  *   .fail(function (response, code) {\n  *     //...\n  *   });\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar extend = core.lib.extend;\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\n\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\nvar RequestQueueMixin = require('./mixins/RequestQueueMixin');\nvar RestSocketRequestDeferred = require('../deferreds/RestSocketRequestDeferred');\nvar SafeParse = require('../wunderbits/lib/SafeParse');\nvar SchemaValidator = require('../validators/SchemaValidator');\nvar URLHelper = require('../helpers/URL');\nvar WebSocket = require('./io/WebSocket');\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:RESTSOCKET');\n\nvar SocketRequestQueueMixin = RequestQueueMixin.extend({\n\n  'maxRequests': 100,\n\n  'executeRequest': function (requestData) {\n\n    var self = this;\n\n    var options = requestData.options;\n\n    self.socketRequest(\n      requestData.deferred,\n      options.method,\n      options.uri,\n      options.data,\n      options.requestID,\n      options.requestType\n    )\n    .always(function executeRequestDone () {\n\n      delete self.executingRequests[requestData.queueID];\n      self.checkQueue();\n    });\n  }\n});\n\nvar _super = WBEventEmitter.prototype;\nvar RestSocket = WBEventEmitter.extend({\n\n  'mixins': [\n    SocketRequestQueueMixin\n  ],\n\n  /** Default RestSocket timout duration in milliseconds (16 seconds) */\n  'timeout': 60 * 1000,\n\n  /** Holds referenece to instance of WebSocket. */\n  'socket': undefined,\n\n  /** Deferred object for getting RestSocket state */\n  'ready': undefined,\n\n  /**\n    * Hash for managing inprogress WebSocket proxied REST requests\n    * @type {object}\n    */\n  'requests': {},\n\n  /**\n    * Wunderlist API RestSocket Module.\n    * Performs restful CRUD operations against the Wunderlist API over a WebSocket Proxy\n    * @constructor\n    * @alias module:io/RestSocket\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.appState = options.appState;\n    self.config = options.config;\n\n    self.ready = new WBDeferred();\n\n    self.socket = new WebSocket(options);\n\n    // set requests hash on instance\n    self.requests = {};\n\n    // verbs are programatically built by _super.initialize\n    // need to override now\n    self.wrapVerbs();\n\n    self.pollForTimeouts();\n    self.bindToSocket();\n    self.ready.resolve();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.unbindAll();\n    self.socket && self.socket.destroy();\n    self.destroyed = true;\n  },\n\n  /**\n    * Wrap the IO verbs\n    */\n  'wrapVerbs': function () {\n\n    var self = this;\n\n    // TODO: merge this with io.js#wrapVerbs\n    // maybe move this into a mixin\n    var verbs = ['get', 'post', 'put', 'patch', 'delete'];\n    verbs.forEach(function (verb) {\n\n      var fn = self[verb];\n      self[verb] = function () {\n        return fn.apply(self, arguments);\n      };\n    });\n  },\n\n  /**\n    * Sets up interval timer to check for request timeouts.\n    */\n  'pollForTimeouts': function () {\n\n    var self = this;\n\n    self.timer && clearInterval(self.timer);\n    self.timer = setInterval(function () {\n\n      self.checkForRequestTimeouts();\n    }, 1000);\n  },\n\n  /**\n    * Close raw WebSocket connection if open.\n    */\n  'close': function () {\n\n    var self = this;\n    self.socket && self.socket.close();\n  },\n\n  /** Binds to WebSocket message events */\n  'bindToSocket': function () {\n\n    var self = this;\n    self.bindTo(self.socket, 'open', 'onSocketConnect');\n    self.bindTo(self.socket, 'message', 'onMessage');\n    self.bindTo(self.socket, 'close', 'onSocketFalure');\n    self.bindTo(self.socket, 'close', 'onSocketDisconnect');\n    self.bindTo(self.socket, 'error', 'onSocketFalure');\n  },\n\n  /**\n    * Real socket is open and ready.  Trigger a connected event.\n    */\n  'onSocketConnect': function (e) {\n\n    var self = this;\n\n    self.getSocketHealth()\n      .done(function () {\n\n        self.connected = true;\n        self.trigger('connected', e);\n        self.pollHealth();\n      })\n      .fail(self.close, self);\n  },\n\n  /**\n    * Starts polling for health\n    */\n  'pollHealth': function () {\n\n    var self = this;\n\n    self.cancelPollHealth();\n\n    self.poller = setInterval(function () {\n\n      if (self.connected) {\n        self.getSocketHealth()\n          .fail(self.close, self);\n      }\n      else {\n        self.cancelPollHealth();\n      }\n    }, 15000);\n  },\n\n  /**\n    * Cancels the poller timer\n    */\n  'cancelPollHealth': function () {\n\n    var self = this;\n    self.poller && clearInterval(self.poller);\n  },\n\n  /**\n    * Get the socket health state\n    * @returns {promise} - A promise that resolves or rejects depending on the health\n    */\n  'getSocketHealth': function () {\n\n    var self = this;\n\n    var request = self.request(undefined, undefined, undefined, undefined, 'health')\n      .done(function (resp, code) {\n\n        localConsole.info('websocket healthy', resp || '', code);\n      })\n      .fail(function (resp, code) {\n\n        localConsole.error('websocket not healthy', resp || '', code);\n      });\n\n    return request.promise();\n  },\n\n  /**\n    * Real socket is closed.  Trigger a disconnected event.\n    */\n  'onSocketDisconnect': function (e) {\n\n    var self = this;\n\n    self.cancelPollHealth();\n    self.connected = false;\n    self.trigger('disconnected', e);\n  },\n\n  /**\n    * Handles incomming messages from WebSocket\n    * @param {event} e - WebSocket event\n    */\n  'onMessage': function (e) {\n\n    var self = this;\n    var data = SafeParse.json(e.data);\n    if (data && data.headers) {\n      data.headers = self.normalizeHeaders(data.headers);\n    }\n\n    var requestID = self.extractRequestIDFromHeaders(data);\n    var request = requestID && self.requests[requestID];\n    self.parseDataBody(data);\n\n    switch (data.type) {\n    case 'request':\n      request && self.handleRequest(request, data, requestID);\n      break;\n    case 'health':\n      request && self.handleHealthRequest(request, data, requestID);\n      break;\n    case 'desktop_notification':\n      self.handleDesktopNotification(data);\n      break;\n    case 'mutation':\n      self.isCorrectMutationVersion(data) && self.handleMessage(data);\n      break;\n    default:\n      self.handleMessage(data);\n    }\n  },\n\n  /**\n    * Extracts the request id from the data\n    * @param {object} data - the request data\n    * @returns {integer} id - the request id\n    */\n  'extractRequestIDFromHeaders': function (data) {\n\n    return data && data.headers && data.headers['x-client-request-id'];\n  },\n\n  /**\n    * Convert body on data to a real object\n    * @param {object} data - the request data\n    */\n  'parseDataBody': function (data) {\n\n    data && data.body && (data.body = SafeParse.json(data.body));\n  },\n\n  /**\n    * Validates realtime mutations to the correct api version\n    * @param {object} mutationData - raw mutation data\n    * @returns {bool}\n    */\n  'isCorrectMutationVersion': function (mutationData) {\n\n    var isCorrectVersion = false;\n\n    var type = mutationData.subject.type;\n    var version = mutationData.version;\n\n    var versionTwoEndpoints = [\n      'file'\n    ];\n\n    var canBeVersionTwo = versionTwoEndpoints.indexOf(type) !== -1;\n    var isVersionTwo = version === 2;\n    var isVersionOne = version === 1;\n\n    if (canBeVersionTwo && (isVersionTwo || isVersionOne)) {\n      isCorrectVersion = true;\n    }\n    else if (isVersionOne) {\n      isCorrectVersion = true;\n    }\n\n    return isCorrectVersion;\n  },\n\n  /**\n    * Handles messages that correspond to requests made by this module.\n    * @param {deferred} request - The request's deferred object.\n    * @param {data} data - The WebSocket message JSON parsed body.\n    */\n  'handleRequest': function (request, data, requestID) {\n\n    var self = this;\n\n    request.endTime = Date.now();\n\n    var okay = /^2/.test(data.status);\n    self.logRequestTimings(okay, request, data);\n\n    if (Array.isArray(data.body)) {\n      data.body.forEach(function (item) {\n\n        if (item.type) {\n          SchemaValidator.validateData(item, item.type);\n        }\n      });\n    }\n    else if (data.body && data.body.type) {\n      SchemaValidator.validateData(data.body, data.body.type);\n    }\n\n    request[okay ? 'resolve' : 'reject'](data.body, data.status);\n    self.checkStillAuthorized(data.status);\n    self.requests[requestID] = undefined;\n  },\n\n  /**\n    * Handles health requests\n    */\n  'handleHealthRequest': function (request, data, requestID) {\n\n    var self = this;\n\n    request.endTime = Date.now();\n\n    var okay = data.body && data.body.healthy === true;\n    self.logRequestTimings(okay, request, data);\n    request[okay ? 'resolve' : 'reject'](data.body, data.status);\n    self.requests[requestID] = undefined;\n  },\n\n  /**\n    * Handles request times\n    */\n  'logRequestTimings': function (okay, request, data) {\n\n    var args = [data.status, request.uri, request.endTime - request.startTime];\n    if (okay) {\n      this.triggerTiming(request);\n      localConsole.info.apply(localConsole, args);\n    }\n    else {\n      localConsole.error.apply(localConsole, args);\n    }\n  },\n\n  /**\n    * Triggers out timings\n    */\n  'triggerTiming': function (requestDeferred) {\n\n    var self = this;\n\n    var requestTime = requestDeferred.startTime;\n    requestDeferred.loadDurationTime = requestDeferred.endTime - requestTime;\n    requestDeferred.latencyTime = requestDeferred.loadDurationTime;\n\n    var timingData = {\n      'start': requestTime,\n      'end': requestDeferred.endTime,\n      'duration': requestDeferred.loadDurationTime,\n      'latency': requestDeferred.latencyTime,\n      // can't find any data available on\n      // websocket messages to calculate download time\n      'download': undefined,\n      'url': requestDeferred.uri,\n      'type': 'websocket'\n    };\n\n    // trigger on self\n    self.trigger('timing:io', timingData);\n  },\n\n  /**\n    * Triggers unauthorized event if the response status is 401.\n    * @param {Number} statusCode - HTTP Status Code\n    * @fires module:io/RestSocket#unauthorized\n    * @todo instance of Wunderlist class should destroy and cleanup self when unauthorized\n    */\n  'checkStillAuthorized': function (statusCode) {\n\n    var unauthorized = 'unauthorized';\n    if (statusCode === 401) {\n      /**\n        * Unauthorized event\n        * @event module:io/RestSocket#unauthorized\n        */\n      this.trigger(unauthorized);\n    }\n  },\n\n  /**\n    * Handle arbitrary WebSocket messages.\n    * @fires module:io/RestSocket#event\n    * @fires module:io/RestSocket#someCRUDOperation\n    */\n  'handleMessage': function (data) {\n\n    var self = this;\n\n    localConsole.debug('arbitrary message', data);\n\n    var type = data && data.subject && data.subject.type;\n    type && SchemaValidator.validateData(data.data, type);\n\n    /**\n      * Socket raw changes endpoint event\n      * @event module:io/RestSocket#event\n      * @type {object}\n      */\n    self.trigger('event', data);\n\n    var operation = data && data.operation;\n    if (operation) {\n      /**\n        * Socket scoped changes endpoint event\n        * @event module:io/RestSocket#someCRUDOperation\n        * @type {object}\n        */\n      self.trigger(operation, data);\n    }\n  },\n\n  /**\n    * Handle desktop notifications.\n    * @fires module:io/RestSocket#desktopNotification\n    */\n  'handleDesktopNotification': function (data) {\n\n    var self = this;\n\n    /**\n      * Socket desktop notifications\n      * @event module:io/RestSocket#desktopNotification\n      * @type {object}\n      */\n    self.trigger('desktopNotification', data);\n  },\n\n  /**\n    * Sets up restful proxy request to the Wunderlist API over a WebSocket\n    * @param {string} method - The rest CRUD operation: POST, GET, PUT, DELETE\n    * @param {string} uri - The API path to proxy to: /api/v1/settings\n    * @param {object} data - Data to send with a POST or PUT.\n    * @param {string} [requestID] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'request': function (method, uri, data, requestID, requestType) {\n\n    var self = this;\n\n    var options = {\n      'method': method,\n      'uri': uri,\n      'data': data,\n      'requestID': requestID,\n      'requestType': requestType\n    };\n\n    var request = self.queueRequest(uri, options, RestSocketRequestDeferred);\n    return request.promise();\n  },\n\n  /**\n    * Sends out a socket request\n    */\n  'socketRequest': function (requestDeferred, method, uri, data, requestID, requestType) {\n\n    var self = this;\n\n    var socket = self.socket;\n\n    requestID = requestID || self.generateUID();\n\n    var headers = self.compileHeaders(requestID);\n\n    var json = {\n      'type': requestType || 'request',\n      'headers': self.normalizeHeaders(headers)\n    };\n\n    method && (json.verb = method);\n    uri && (json.uri = uri);\n\n    if ((method === 'POST' || method === 'PATCH' || method === 'PUT') && data) {\n      json.body = JSON.stringify(data);\n    }\n\n    // add additional request information to the request deferred object\n    requestDeferred.requestID = requestID;\n    requestDeferred.uri = uri;\n    requestDeferred.startTime = Date.now();\n\n    self.requests[requestID] = requestDeferred;\n\n    // only send messages if the socket is still connected\n    if (self.appState.isOnline() && self.socket.isConnected()) {\n      socket.send(JSON.stringify(json));\n    }\n    else {\n      requestDeferred.reject({\n        'errors': ['no websocket connection available']\n      }, 0);\n    }\n\n    return requestDeferred.promise();\n  },\n\n  /**\n    * Compiles headers\n    */\n  'compileHeaders': function (requestID) {\n\n    var self = this;\n    var headers = {\n      'x-client-request-id': requestID,\n      'x-client-id': self.appState.attributes.clientID,\n      'x-client-instance-id': self.appState.attributes.instanceID,\n      'x-client-device-id': self.appState.attributes.deviceID,\n      'content-type': 'application/json',\n      'accept': 'application/json'\n    };\n\n    headers = extend(headers, PlatformHeaders.headers);\n\n    if (self.config && (typeof self.config.extendHeaders === 'function')) {\n      self.config.extendHeaders(headers);\n    }\n\n    var val;\n    for (var header in headers) {\n      val = headers[header];\n      if (val === undefined || val === null) {\n        delete headers[header];\n      }\n    }\n\n    return headers;\n  },\n\n  /**\n    * Normalizes headers to all lowercase\n    */\n  'normalizeHeaders': function (headers) {\n\n    var normalize = {};\n\n    for (var key in headers) {\n      normalize[key.toLowerCase()] = headers[key];\n    }\n\n    return normalize;\n  },\n\n  /**\n    * Wrapper for CRUD methods that calls #request when WebSocket is ready.\n    * @returns {promise} Request promise.\n    */\n  'requestWrapper': function (method, path, data, requestId) {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    path = '/api' + path;\n\n    self.ready.done(function () {\n\n      self.request(method, path, data, requestId)\n        .done(deferred.resolve.bind(deferred))\n        .fail(deferred.reject.bind(deferred));\n    });\n\n    return deferred.promise();\n  },\n\n  /**\n    * Cancel all request on a socket failure event (close, error)\n    */\n  'onSocketFalure': function () {\n\n    var self = this;\n    var request;\n    for (var requestID in self.requests) {\n      request = self.requests[requestID];\n      request && request.reject({\n        'errors': ['websocket connection lost']\n      }, 0);\n      self.requests[requestID] = undefined;\n    }\n  },\n\n  /**\n    * Check for request timeouts.\n    */\n  'checkForRequestTimeouts': function () {\n\n    var self = this;\n    var now = Date.now();\n\n    for (var requestID in self.requests) {\n      self.checkRequestIsTimedout(self.requests[requestID], now);\n    }\n  },\n\n  /**\n    * Check if a request is timedout.\n    * @param {defferred} requestDeferred - Request deffered object\n    * @param {number} now - The time in milliseconds\n    */\n  'checkRequestIsTimedout': function (requestDeferred, now) {\n\n    var self = this;\n    if (requestDeferred && now - requestDeferred.startTime >= self.timeout) {\n\n      localConsole.error('timeout', requestDeferred.uri, now - requestDeferred.startTime);\n\n      requestDeferred.reject({\n        'errors': ['request timedout locally due to no response in ' + self.timeout]\n      }, 408);\n      self.requests[requestDeferred.requestID] = undefined;\n    }\n  },\n\n  /**\n    * Makes a DELETE proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} [params] - Params to send as part of delete request.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'delete': function (uri, params, requestId) {\n\n    var url = uri + URLHelper.compileParams(params);\n    return this.requestWrapper('DELETE', url, undefined, requestId);\n  },\n\n  /**\n    * Makes a GET proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} params - Request parameters (key value hash)\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'get': function (uri, params, requestId) {\n\n    var url = uri + URLHelper.compileParams(params);\n    return this.requestWrapper('GET', url, undefined, requestId);\n  },\n\n  /**\n    * Makes a PATCH proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'patch': function (uri, data, requestId) {\n    return this.requestWrapper('PATCH', uri, data, requestId);\n  },\n\n  /**\n    * Makes a POST proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'post': function (uri, data, requestId) {\n    return this.requestWrapper('POST', uri, data, requestId);\n  },\n\n  /**\n    * Makes a PUT proxy request over WebSocket.\n    * @param {string} uri - Path to Wunderlist API endpoint.\n    * @param {object} data - Data to send.\n    * @param {string} [requestId] - Optional request_id, if not provided a UID will be generated for the request.\n    * @returns {promise} Request promise.\n    */\n  'put': function (uri, data, requestId) {\n\n    return this.requestWrapper('PUT', uri, data, requestId);\n  },\n\n  /**\n    * Generates unique indentifiers for proxy requests.\n    * @returns {string} UID\n    */\n  'generateUID': function () {\n\n    var self = this;\n    var uid;\n\n    while (!uid || !self.isUIDValid(uid)) {\n      uid = createUID();\n    }\n\n    return uid;\n  },\n\n  /**\n    * Checks that UID is not already used by a pending known request.\n    * @param {string} uid - UID\n    * @returns {boolean} - returns TRUE iff valid\n    */\n  'isUIDValid': function (uid) {\n    return !(uid in this.requests);\n  },\n\n  /**\n    * Cancels in-flight socket requests\n    */\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n    var request = self.requests[requestID];\n\n    localConsole.debug('cancelling request locally', requestID, 'alive?', !!request);\n\n    if (request) {\n      self.requests[requestID] = undefined;\n      var data = onlineID ? {'id': onlineID} : {};\n      data.revision = revision;\n      request.resolve(data, 200);\n    }\n  }\n});\n\nmodule.exports = RestSocket;\n",
    "'use strict';\n\n/**\n  * Ajax transport that permits a maximum number of open http connections.\n  * Queueing and flushing is handled automagically.\n  * @module io/io/AjaxTransport\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBDeferred\n  * @requires module:wunderbits.core/lib/createUID\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/lib/SafeParse\n  * @requires module:io/io/NativeXMLHttpRequest\n  *\n  * @example\n  * var ajax = require('io/io/AjaxTransport').ajax;\n  * var request = ajax('http://www.example.comt/api/endpoint', {\n  *   'type': 'GET',\n  *   'data': {\n  *     'param': 'value'\n  *   },\n  *   'success': function (data, xhr) {//...},\n  *   'error': function (data, xhr) {//...}\n  * });\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\nvar WBBindableMixin = core.mixins.WBBindableMixin;\nvar WBEventsMixin = core.mixins.WBEventsMixin;\n\nvar urlHelper = require('../../helpers/URL');\nvar SafeParse = require('../../wunderbits/lib/SafeParse');\nvar XHR = require('./NativeXMLHttpRequest');\nvar RequestDeferred = require('../../deferreds/RequestDeferred');\nvar RequestQueueMixin = require('../mixins/RequestQueueMixin');\n\nvar AjaxRequestQueueMixin = RequestQueueMixin.extend({\n\n  'maxRequests': 5,\n\n  /**\n  * Executes a pending request\n  * @param {object} requestData - queued request data\n  */\n  'executeRequest': function (requestData) {\n\n    var self = this;\n\n    var url = requestData.url;\n    var options = requestData.options;\n    var deferred = requestData.deferred;\n\n    self.executingRequests[requestData.queueID] = requestData;\n\n    var request = self.xhrRequest(url, {\n\n      'type': options.type,\n      'data': options.data,\n      'headers': options.headers,\n      'timeout': options.timeout\n    }, deferred);\n\n    request\n      .done(function (data, xhr) {\n\n        self.onSuccess(data, xhr, options);\n      })\n      .fail(function (data, xhr) {\n\n        self.onFailure(data, xhr, options);\n      })\n      .always(function () {\n\n        delete self.executingRequests[requestData.queueID];\n        self.checkQueue();\n      });\n  }\n});\n\nvar AjaxTransport = WBSingleton.extend({\n\n  'mixins': [\n    WBBindableMixin,\n    WBEventsMixin,\n    AjaxRequestQueueMixin\n  ],\n\n  /**\n    * Creates and sends an XMLHttpRequest\n    * @param {string} url - url for the request\n    * @param {object} options - request options\n    * @param {string} options.type - request type/method, GET, POST, PUT, DELETE\n    * @param {object} [options.data] - request data.  Automatically converted to url params for GET requests\n    * @param {number} [options.timeout] - request timeout duration\n    * @param {object} [options.headers] - request headers\n    * @param {deferred} requestDeferred - request deferred object\n    */\n  'xhrRequest': function (url, options, requestDeferred) {\n\n    var self = this;\n\n    var async = true;\n    var method = options.type;\n    var data = options.data;\n\n    // // move data to URL as params\n    if (data && method === 'GET') {\n      url = urlHelper.generateURI(url, data);\n      // unset data so it is not used further down\n      data = undefined;\n    }\n\n    // Open request\n    var request = new XHR();\n\n    // set handlers (BEFORE #OPEN)\n    self.attachXhrListeners(request, requestDeferred);\n\n    request.open(method, url, async);\n\n    // setup timeout (AFTER #OPEN)\n    if (options.timeout) {\n      request.timeout = options.timeout;\n    }\n\n    // set headers (BEFORE #SEND)\n    self.setupXhrHeaders(request, options.headers, data);\n\n    requestDeferred.startTime = Date.now();\n\n    data ? request.send(data) : request.send();\n\n    // expose some useful things on the deferred request object:\n    requestDeferred.url = url;\n    requestDeferred.xhr = request;\n\n    return requestDeferred;\n  },\n\n  /**\n    * Sets up appropriate headers for an XMLHttpRequest\n    * @param {XMLHttpRequest} request - XMLHttpRequest\n    * @param {object} [headers] - custom headers\n    * @param {object} [data] - request data, if present content-type application/json header will be set\n    */\n  'setupXhrHeaders': function (request, headers, data) {\n\n    var weSpeakJSON = 'application/json; charset=utf-8';\n\n    // set request headers\n    if (headers) {\n      for (var header in headers) {\n        request.setRequestHeader(header.toLowerCase(), headers[header]);\n      }\n    }\n\n    // Set the correct headers for content-type and accept\n    // Note: these are case sensitive for the node XHR object, do not to lower them!\n    if (data) {\n      request.setRequestHeader('Content-Type', weSpeakJSON);\n    }\n    // Set accept header\n    request.setRequestHeader('Accept', weSpeakJSON);\n  },\n\n  /**\n    * Attaches event listeners to an XMLHttpRequest\n    * @param {XMLHttpRequest} request - XMLHttpRequest\n    * @param {requestDeferred} requestDeferred - request deferred\n    */\n  'attachXhrListeners': function (request, requestDeferred) {\n\n    var self = this;\n\n    // handlers\n    request.addEventListener('progress', function (ev) {\n\n      self.onXhrProgress(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('load', function (ev) {\n\n      self.onXhrLoad(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('error', function (ev) {\n\n      self.onXhrError(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('abort', function (ev) {\n\n      self.onXhrAbort(ev, request, requestDeferred);\n    }, false);\n    request.addEventListener('timeout', function (ev) {\n\n      self.onXhrTimeout(ev, request, requestDeferred);\n    }, false);\n  },\n\n  /**\n    * Handles rejecting or reolving request deferred\n    * @param {event} ev - raw event object from XMLHttpRequest\n    * @param {XMLHttpRequest} request - the originating XMLHttpRequest\n    * @param {requestDeferred} requestDeferred - the request deferred object\n    */\n  'onXhrLoad': function (ev, request, requestDeferred) {\n\n    var self = this;\n\n    var isSuccess = parseInt(request.status / 100, 10) === 2;\n    if (isSuccess) {\n      self.triggerTiming(requestDeferred);\n    }\n\n    requestDeferred[isSuccess ? 'resolve' : 'reject'].call(requestDeferred, request.responseText, request);\n  },\n\n  'triggerTiming': function (requestDeferred) {\n\n    var self = this;\n\n    var now = Date.now();\n    var requestTime = requestDeferred.startTime;\n    var loadStart = requestDeferred.loadStartTime;\n    requestDeferred.loadDurationTime = now - loadStart;\n    requestDeferred.latencyTime = loadStart - requestTime;\n\n    self.trigger('timing:io', {\n      'start': requestTime,\n      'end': now,\n      'duration': now - requestTime,\n      'latency': requestDeferred.latencyTime,\n      'download': requestDeferred.loadDurationTime,\n      'url': requestDeferred.url,\n      'type': 'ajax'\n    });\n  },\n\n  'onXhrProgress': function (ev, request, requestDeferred) {\n\n    if (!requestDeferred.loadStarted) {\n      requestDeferred.loadStartTime = Date.now();\n      requestDeferred.loadStarted = true;\n    }\n  },\n\n  /** Handles XMLHttpRequest error events */\n  'onXhrError': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrError', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest abort events */\n  'onXhrAbort': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrAbort', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest timeout events */\n  'onXhrTimeout': function (ev, request, requestDeferred) {\n\n    // console.log('onXhrTimeout', ev);\n    this.onXhrFail(ev, request, requestDeferred);\n  },\n\n  /** Handles XMLHttpRequest failure events */\n  'onXhrFail': function (ev, request, requestDeferred) {\n\n    requestDeferred.reject(request.responseText, request);\n  },\n\n  /**\n    * Main transport request method\n    * @param {string} url - request url\n    * @param {object} options - request options\n    * @returns {deferred}\n    */\n  'ajax': function (url, options) {\n\n    var self = this;\n    var request = self.queueRequest(url, options, RequestDeferred);\n    return request;\n  },\n\n  /** Handles successful ajax request responses */\n  'onSuccess': function (data, xhr, options) {\n\n    if (typeof data === 'string' && xhr.status !== 204) {\n      data = SafeParse.json(data);\n    }\n\n    options.success && options.success(data, xhr);\n  },\n\n  /** Handles unsuccessful ajax request responses */\n  'onFailure': function (data, xhr, options) {\n\n    // this does not work with cross-domain firefox,\n    // it will always return an empty string\n    // yay mozilla!!\n    var contentType = (xhr.getResponseHeader('content-type') || '').split(';')[0];\n    if (typeof data === 'string' && (/application\\/json/.test(contentType))) {\n      data = SafeParse.json(xhr.responseText);\n    }\n\n    if (typeof options.error === 'function') {\n      options.error(data, xhr);\n    }\n  }\n});\n\nmodule.exports = AjaxTransport;",
    "(function (global){\n'use strict';\n\n/**\n  * Returns browser WebSocket reference, or node.js WebSocket module ws\n  * @module io/io/NativeWebSocket\n  */\n\nmodule.exports = global.WebSocket || require('ws');\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "(function (global){\n'use strict';\n\n/**\n  * Returns browser XMLHttpRequest reference, or node.js xmlhttprequest reference\n  * @module io/io/NativeXMLHttpRequest\n  */\n\nmodule.exports = global.XMLHttpRequest || require('xmlhttprequest').XMLHttpRequest;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\n/**\n  * @module io/io/WebSocket\n  * @requires module:wunderbits.core/lib/assert\n  * @requires module:wunderbits.core/WBEventEmitter\n  * @requires module:helpers/URL\n  * @requires module:magiconsole\n  * @requires module:io/io/NativeWebSocket\n  * @requires module:wunderbits/lib/bindAll\n  * @extends module:wunderbits.core/WBEventEmitter\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar assert = core.lib.assert;\n\nvar URLHelper = require('../../helpers/URL');\nvar NativeWebSocket = require('./NativeWebSocket');\nvar bindAll = require('../../wunderbits/lib/bindAll');\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:WEBSOCKET');\n\nvar _super = WBEventEmitter.prototype;\n\nvar WebSocketClass = WBEventEmitter.extend({\n\n  /**\n    * Was the socket connection close done by the client?\n    */\n  'clientClosed': false,\n\n  'NativeWebSocketClass': NativeWebSocket,\n\n  /** Holds reference to instance of native WebSocket */\n  'socket': undefined,\n\n  /**\n    * Wunderlist API native WebSocket Module\n    * @constructor\n    * @alias module:io/io/WebSocket\n    */\n  'initialize': function (options) {\n\n    var self = this;\n\n    self.appState = options.appState;\n\n    _super.initialize.apply(self, arguments);\n\n    // TODO: remove this ugly piece of shit, we don't need more binds\n    var fns = ['onSocketClose', 'onSocketError', 'onSocketMessage', 'onSocketOpen'];\n    bindAll(self, fns);\n\n    self.validateToken();\n    self.connect();\n    self.bindToAppState();\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.close();\n    self.unbindAll();\n    self.destroyed = true;\n  },\n\n  'bindToAppState': function () {\n\n    var self = this;\n\n    if (self.appState) {\n      self.unbindFrom(self.appState);\n      self.bindTo(self.appState, 'change:online', function () {\n\n        self[self.appState.isOnline() ? 'connect' : 'close']();\n      });\n    }\n  },\n\n  /** Validates that there is an access token */\n  'validateToken': function () {\n\n    assert.string(this.appState.attributes.accessToken, 'Cannot instantiate class without an auth token.');\n  },\n\n  /** Connects to Wunderlist API WebSocket */\n  'connect': function () {\n\n    var self = this;\n\n    // close any prexising sockets\n    self.socket && self.close();\n\n    self.clientClosed = false;\n    self.clearSocketTimeout();\n\n    var config = self.appState.attributes;\n\n    var params = {\n      'client_id': config.clientID,\n      'access_token': config.accessToken,\n      'client_device_id': config.deviceID,\n      'client_instance_id': config.instanceID\n    };\n\n    var host = self.appState.attributes.realtime.host;\n    var url = URLHelper.generateURI(host, params);\n\n    var NativeWebSocketClass = self.NativeWebSocketClass;\n    self.socket = new NativeWebSocketClass(url);\n    self.bindToSocket();\n  },\n\n  /**\n    * Is the web socket really connected?\n    */\n  'isConnected': function () {\n\n    var socket = this.socket;\n    return !!(socket && socket.readyState === 1);\n  },\n\n  /**\n    * Sends a message to the Wunderlist API through connected WebSocket\n    * @param {string} message - Message to send.\n    */\n  'send': function (message) {\n\n    this.socket.send(message);\n  },\n\n  /**\n    * Close WebSocket connection if open.\n    */\n  'close': function () {\n\n    var self = this;\n    self.clientClosed = true;\n    if (self.socket) {\n      self.socket.close();\n      self.socket = undefined;\n    }\n  },\n\n  /** Binds to native WebSocket events: close, error, message, open */\n  'bindToSocket': function () {\n\n    var self = this;\n    var socket = self.socket;\n\n    socket.addEventListener('close', self.onSocketClose);\n    socket.addEventListener('error', self.onSocketError);\n    socket.addEventListener('message', self.onSocketMessage);\n    socket.addEventListener('open', self.onSocketOpen);\n\n    self.trackTimeout();\n  },\n\n  /**\n    * Timout pending socket connection after _timeout duration.\n    */\n  'trackTimeout': function () {\n\n    var self = this;\n    var timeout = self.appState.attributes.webSocketTimeout;\n\n    var start = Date.now();\n\n    var socketTimeoutLoop = function () {\n\n      if (self.socket && self.socket.readyState === 0) {\n        if (Date.now() - start < timeout) {\n          self.socketTimeout = setTimeout(socketTimeoutLoop, 1000);\n        }\n        else {\n          self.onSocketTimeout();\n          if (self.socket) {\n            self.socket.close();\n            self.socket = undefined;\n          }\n        }\n      }\n    };\n    socketTimeoutLoop();\n  },\n\n  /**\n    * Clear socketTimeout timer\n    */\n  'clearSocketTimeout': function () {\n\n    var self = this;\n    self.socketTimeout && clearTimeout(self.socketTimeout);\n  },\n\n  /**\n    * @fires module:WebSocket#timeout\n    */\n  'onSocketTimeout': function (ms) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    localConsole.error('timeout', ms);\n    /**\n      * @event module:io/io/WebSocket#timeout\n      */\n    self.trigger('timeout');\n  },\n\n  /**\n    * @fires module:WebSocket#error\n    */\n  'onSocketError': function (e) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    localConsole.error('error', e);\n    /**\n      * @event module:io/io/WebSocket#error\n      * @type {event}\n      */\n    self.trigger('error', e);\n  },\n\n  /**\n    * @fires module:WebSocket#open\n    */\n  'onSocketOpen': function (e) {\n\n    var self = this;\n\n    localConsole.info('opened', e);\n    /**\n      * @event module:io/io/WebSocket#open\n      * @type {event}\n      */\n    self.trigger('open', e);\n  },\n\n  /**\n    * @fires module:WebSocket#close\n    */\n  'onSocketClose': function (e) {\n\n    var self = this;\n\n    self.clearSocketTimeout();\n    self.socket = undefined;\n    localConsole.info('closed', e);\n    /**\n      * @event module:io/io/WebSocket#close\n      * @type {event}\n      */\n    self.trigger('close', e);\n\n    /**\n      * @todo REMOVE THIS, THIS IS A HACK WHILE PLAY FRAMEWORK IS BROKEN\n      */\n    if (!self.clientClosed && self.appState.isOnline()) {\n\n      setTimeout(function () {\n\n        !self.destroyed && self.connect();\n      }, 1000);\n    }\n  },\n\n  /**\n    * @fires module:WebSocket#message\n    */\n  'onSocketMessage': function (e) {\n\n    var self = this;\n    /**\n      * @event module:io/io/WebSocket#message\n      * @type {event}\n      */\n    self.trigger('message', e);\n  }\n});\n\nmodule.exports = WebSocketClass;\n",
    "'use strict';\n\n/**\n  * Request queue mixin for throttling http and rest socket requests\n  * @module io/mixins/RequestQueueMixin\n  * @extends wunderbits/WBMixin\n  * @requires validators/SchemaValidator\n  */\n\nvar core = require('wunderbits.core');\nvar createUID = core.lib.createUID;\nvar WBMixin = core.WBMixin;\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Maximum number of open ajax requests.\n    * @type {number}\n    */\n  'maxRequests': 5,\n\n  /**\n    * Queue of pending ajax requests\n    * @type {array}\n    */\n  'requestsQueue': [],\n\n  /**\n    * Hash of currently executing ajax requests\n    * @type {object}\n    */\n  'executingRequests': {},\n\n  /** Resets queues*/\n  'reset': function () {\n\n    var self = this;\n    self.requestsQueue = [];\n    self.executingRequests = {};\n  },\n\n  /** Checks request queue for pending requests and flushes if allowed*/\n  'checkQueue': function () {\n\n    var self = this;\n    var requests = Object.keys(self.executingRequests).length;\n    var requestData;\n\n    if (requests < self.maxRequests) {\n      requestData = self.requestsQueue.shift();\n      requestData && self.executeRequest(requestData);\n    }\n  },\n\n  /**\n    * Queues a request and creates request's deffered object.\n    * @param {string} url - request URL\n    * @param {object} options - request options\n    * @param {constructor} RequestDeferredClass - request deferred contructor\n    * @returns {deferred}\n    */\n  'queueRequest': function (url, options, RequestDeferredClass) {\n\n    var self = this;\n    var deferred = new RequestDeferredClass();\n\n    self.requestsQueue.push({\n\n      'deferred': deferred,\n      'url': url,\n      'options': options,\n      'queueID': createUID()\n    });\n\n    self.checkQueue();\n\n    return deferred;\n  },\n\n  'executeRequest': function (requestData) {\n\n    throw new Error('You must override RequestQueueMixin#executeRequest!', requestData);\n\n    // // Example from AjaxTransport#executeRequest\n    // var self = this;\n\n    // var url = requestData.url;\n    // var options = requestData.options;\n    // var deferred = requestData.deferred;\n\n    // self.executingRequests[requestData.queueID] = requestData;\n\n    // var request = self.xhrRequest(url, {\n\n    //   'type': options.type,\n    //   'data': options.data,\n    //   'headers': options.headers,\n    //   'timeout': options.timeout\n    // }, deferred);\n\n    // request\n    //   .done(function (data, xhr) {\n\n    //     self.onSuccess(data, xhr, options);\n    //   })\n    //   .fail(function (data, xhr) {\n\n    //     self.onFailure(data, xhr, options);\n    //   })\n    //   .always(function () {\n\n    //     delete self.executingRequests[requestData.queueID];\n    //     self.checkQueue();\n    //   });\n  }\n});\n",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\nvar WBStateModel = core.WBStateModel;\nvar clone = core.lib.clone;\nvar WBOnlineStatus = require('../wunderbits/WBOnlineStatus');\n\nvar _super = WBStateModel.prototype;\nvar ApplicationState = WBStateModel.extend({\n\n  'defaults': {\n    'api': {\n      'host': 'https://a.wunderlist.com/api',\n    },\n    'realtime': {\n      'host': 'wss://socket.wunderlist.com:8443/api/v1/sync'\n    },\n    'accessToken': undefined,\n    'clientID': undefined,\n    'debug': false,\n    'online': true,\n    'webSocketTimeout': 15 * 1000,\n    'maxHttpRequests': 5,\n    'checkHealth': true\n  },\n\n  'initialize': function () {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.initialized = new WBDeferred();\n\n    setTimeout(function () {\n\n      if (self.destroyed) {\n        return;\n      }\n\n      // Hack until wb.core is updated with correct initialize chains\n      self.watchOnlineState();\n      self.initialized.resolve();\n    });\n  },\n\n  'destroy': function () {\n\n    var self = this;\n\n    self.onlineState && self.onlineState.destroy();\n    _super.destroy.apply(self, arguments);\n  },\n\n  'watchOnlineState': function () {\n\n    var self = this;\n\n    if (self.onlineState) {\n      self.unbindFrom(self.onlineState);\n      self.onlineState.destroy();\n    }\n\n    self.onlineState = new WBOnlineStatus({\n      'config': self.toJSON()\n    });\n\n    self.set('online', self.onlineState.isOnline());\n\n    self.bindTo(self.onlineState, 'online', 'onOnline');\n    self.bindTo(self.onlineState, 'offline', 'onOffline');\n  },\n\n  'onOnline': function () {\n\n    this.set('online', true);\n  },\n\n  'onOffline': function () {\n\n    this.set('online', false);\n  },\n\n  'isOnline': function () {\n\n    return !!this.attributes.online;\n  },\n\n  'toJSON': function () {\n\n    return clone(this.attributes);\n  }\n});\n\nmodule.exports = ApplicationState;",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar clone = core.lib.clone;\nvar extend = core.lib.extend;\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'task_id': SchemaTypes.id,\n  'list_id': SchemaTypes.id,\n  'user_id': SchemaTypes.id,\n\n  'revision': SchemaTypes.int,\n  'type': SchemaTypes.str,\n\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n\n  'extend': function (obj) {\n    return extend(clone(this), obj);\n  }\n};\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'title': SchemaTypes.str,\n  'list_ids': SchemaTypes.arr,\n  'user_id': SchemaTypes.id,\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n  'revision': SchemaTypes.int,\n  'type': SchemaTypes.str\n};",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'created_by_id': SchemaTypes.id,\n  'list_type': SchemaTypes.str,\n  'title': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'sender_id': SchemaTypes.id,\n  'state': SchemaTypes.str,\n  'owner': SchemaTypes.bool,\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'content': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id\n};\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'values': SchemaTypes.arr\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'date': SchemaTypes.ISODate\n});\n",
    "'use strict';\n\nmodule.exports = {\n  'id': 'integer',\n  'int': 'integer',\n  'bool': 'boolean',\n  'arr': 'array',\n  'str': 'string',\n  'ISODate': 'ISODate'\n};\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'user_id': SchemaTypes.id,\n  'provider_id': SchemaTypes.str,\n  'provider_type': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'key': SchemaTypes.str,\n  'value': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'completed': SchemaTypes.bool,\n  'completed_at': SchemaTypes.ISODate,\n  'completed_by_id': SchemaTypes.id,\n\n  'created_by_id': SchemaTypes.id,\n  'title': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'assignee_id': SchemaTypes.id,\n\n  'completed': SchemaTypes.bool,\n  'completed_at': SchemaTypes.ISODate,\n  'completed_by_id': SchemaTypes.id,\n\n  'created_by_id': SchemaTypes.id,\n\n  'due_date': SchemaTypes.ISODate,\n\n  'starred': SchemaTypes.bool,\n\n  'title': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'read': SchemaTypes.bool,\n  'text': SchemaTypes.str\n});\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\n\nmodule.exports = {\n  'id': SchemaTypes.id,\n  'name': SchemaTypes.str,\n  'organization_id': SchemaTypes.id,\n  'created_at': SchemaTypes.ISODate,\n  'updated_at': SchemaTypes.ISODate,\n  'revision': SchemaTypes.int,\n  'team_type': SchemaTypes.str,\n  'type': SchemaTypes.str\n};\n",
    "'use strict';\n\nvar SchemaTypes = require('./SchemaTypes');\nvar BaseSchema = require('./BaseSchema');\n\nmodule.exports = BaseSchema.extend({\n  'name': SchemaTypes.str,\n  'email': SchemaTypes.str,\n  'pro': SchemaTypes.bool\n});\n",
    "'use strict';\n\nvar PositionSchema = require('./Position');\n\nmodule.exports = {\n  'list': require('./List'),\n  'folder': require('./Folder'),\n  'membership': require('./Membership'),\n  'note': require('./Note'),\n  'reminder': require('./Reminder'),\n  'setting': require('./Setting'),\n  'service': require('./Service'),\n  'subtask': require('./Subtask'),\n  'task': require('./Task'),\n  'task_comment': require('./TaskComment'),\n  'user': require('./User'),\n  'team': require('./Team'),\n  'organization': require('./Organization'),\n  'list_position': PositionSchema,\n  'subtask_position': PositionSchema,\n  'task_position': PositionSchema\n};",
    "'use strict';\n\n/**\n  * Provides access to HTML string last 100 activities\n  * @module services/Activities\n  * @extends module:services/Conversations\n  * @requires module:services/Conversations\n\n  * @example <caption>Get HTML page with 100 latest activities</caption>\n    var ActivitiesService = require('services/Activities');\n    var activities = new ActivitiesService();\n    activities.all({\n        'style': 'desktop',\n        'tz_offset': -8\n      })\n      .done(function (data, statusCode) {\n        console.log(data.html);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar ConversationsService = require('./Conversations');\n\nmodule.exports = ConversationsService.extend({\n  'baseUrl': '/activities',\n  'type': 'activities'\n});\n",
    "'use strict';\n\n/**\n  * @module services/AuthenticatedService\n  * @extends module:services/Service\n  * @requires module:services/Service\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\n\nvar BaseService = require('./Service');\n\nvar _super = BaseService.prototype;\n\nmodule.exports = BaseService.extend({\n\n  /**\n    * Base class for Wunderlist API service modules that require authentication.\n    * @constructor\n    * @alias module:services/AuthenticatedService\n    */\n  'initialize': function () {\n    var self = this;\n    _super.initialize.apply(self, arguments);\n    self.validateAccessParams();\n  },\n\n  /**\n    * Checks that clientID and accessToken are available\n    */\n  'validateAccessParams': function () {\n\n    var self = this;\n    var config = self.appState.attributes;\n    assert.string(config.clientID, 'This service requires a client ID.');\n    assert.string(config.accessToken, 'This service requires an access token.');\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides access to HTML string last 100 conversations\n  * @module services/Conversations\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Get HTML page with 100 latest conversations</caption>\n    var Conversations = require('services/Conversations');\n    var conversations = new ConversationsService();\n    conversations.all({\n        'style': 'desktop',\n        'tz_offset': -8\n      })\n      .done(function (data, statusCode) {\n        console.log(data.html);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/conversations',\n  'type': 'conversations',\n\n  'all': function (params, requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, params, requestID).promise();\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides access to the export service\n  * @module services/Export\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/export',\n  'type': 'export',\n\n  'all': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID, 300000).promise();\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides access to user's features\n  * @module services/Features\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/features',\n\n  'type': 'feature'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to files data.\n  * @module services/Files\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Files service</caption>\n    var FilesService = require('services/Files');\n    var files = new FilesService();\n\n  * @example <caption>Get files for a task</caption>\n    var taskID = 78987;\n    files.forTask(taskID)\n      .done(function (filesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get files for a list</caption>\n    var listID = 87987;\n    files.forList(listID)\n      .done(function (filesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific file</caption>\n    var fileID = 34958737;\n    files.getID(fileID)\n      .done(function (fileData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a file</caption>\n    var fileData = {\n      'upload_id': 458748574,\n      'task_id': 4958,\n      'file_name': 'awesome file.zip'\n    };\n    notes.create(noteData)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a file</caption>\n    var fileID = 3487348374;\n    var revision = 45;\n    notes.deleteID(fileID, revision)\n      .always(function (resp, statusCode) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:FILES');\n\nvar AuthenticatedService = require('./AuthenticatedService');\nvar _super = AuthenticatedService.prototype;\n\nmodule.exports = AuthenticatedService.extend({\n\n  'apiVersion': 2,\n  'baseUrl': '/files',\n  'type': 'file',\n\n  'create': function (data, requestID) {\n\n    var self = this;\n\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.call(self, data, requestID);\n    return request.promise();\n  },\n\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for file creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.task_id, 'data.task_id' + required);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides access for fetching the user's ical feed url\n  * @module services/Products\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nmodule.exports = ServiceGetOnly.extend({\n\n  'baseUrl': '/ical/feed',\n  'type': 'ical_feed',\n\n  'getURL': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID).promise();\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to the import endpoint.\n  * @module services/Import\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/import',\n  'type': 'import',\n\n  'create': function (data, requestID) {\n\n    var self = this;\n    return self.post(self.baseUrl, data, requestID, 300000).promise();\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to list positions.\n  * @module services/ListPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the ListPositions service</caption>\n    var ListPositionsService = require('services/ListPositions');\n    var listPositions = new ListPositionsService();\n\n\n  * @example <caption>Get all list positions</caption>\n    var ListPositions = require('services/ListPositions');\n    var listPositions = new ListPositions();\n    listPositions.all()\n      .done(function (listPositions, statusCode) {\n        //...\n      })\n      .fail(function (resp, code) {\n        //...\n      });\n\n  * @example <caption>Update a lists positions object</caption>\n    var listPositionsID = 678;\n    var listPositionsRevision = 6;\n    var updateData = {\n      'values': [123,345,567]\n    };\n    listPositions.update(listPositionsID, listPositionsRevision, updateData)\n      .done(function (listPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/list_positions',\n  'type': 'list_position'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to users data.\n  * @module services/Users\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Users service</caption>\n    var UsersService = require('services/Users');\n    var users = new UsersService();\n\n  * @example <caption>Fetch the users this logged in user can access</caption>\n    users.all()\n      .done(function (usersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/list_reminders_collections',\n  'type': 'list_reminders_collection'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to list data.\n  * @module services/Lists\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Lists service</caption>\n    var ListsService = require('services/Lists');\n    var lists = new ListsService();\n\n  * @example <caption>Get all lists for a user_id</caption>\n    var userID = 984587;\n    lists.forUser(listID)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific list</caption>\n    vat listID = 777;\n    lists.getID(listID)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a list</caption>\n    lists.create({\n      'title': 'Bad Movies'\n    })\n    .done(function (listData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a list</caption>\n    var listID = 777;\n    var listRevision = 5;\n    var updateData = {\n      'title': 'Good Bad Movies',\n    };\n\n    lists.update(listID, listRevision, updateData)\n      .done(function (listData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a list</caption>\n    var listID = 777;\n    var listRevision = 5;\n    lists.deleteID(listID, listRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:LISTS');\n\nvar MembershipsService = require('./Memberships');\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/lists',\n\n  'type': 'list',\n\n\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.membershipsService = new MembershipsService(options);\n  },\n\n  /**\n    * Create a list.\n    * @param {object} data - List creation data.\n    * @param {string} data.title - List title.\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Returns current user's accepted lists only\n    */\n  'accepted': function () {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    self.membershipsService.mine()\n      .done(function (myMemberships) {\n\n        var acceptedMemberships = myMemberships.filter(function (membership) {\n\n          return membership.state === 'accepted';\n        });\n\n        var acceptedIDs = acceptedMemberships.map(function (acceptedMembership) {\n\n          return acceptedMembership.list_id;\n        });\n\n        self.all()\n          .done(function (allLists) {\n\n            var myLists = allLists.filter(function (list) {\n\n              return acceptedIDs.indexOf(list.id) > -1;\n            });\n\n            deferred.resolve(myLists);\n          })\n          .fail(deferred.reject, deferred);\n      })\n      .fail(deferred.reject, deferred);\n\n    return deferred.promise();\n  },\n\n  /**\n    * Validates subtask creation data.\n    * @param {object} data - Subtask data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n    assert(data.title, 'Title is required for list creation.');\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to memberships data.\n  * @module services/Memberships\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Memberships service</caption>\n    var MembershipsService = require('services/Memberships');\n    var memberships = new MembershipsService();\n\n  * @example <caption>Get all memberships for a user</caption>\n    var userID = 5687;\n    memberships.forUser(userID)\n      .done(function (memberhipsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all memberships for a list</caption>\n    var listID = 56879;\n    memberships.forList(listID)\n      .done(function (memberhipsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Invite a user to a list</caption>\n    var membershipData = {\n      'list_id': 5687,\n      'user_id': 4340598\n    };\n    memberships.create(membershipData)\n      .done(function (newMembership, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Invite an email address to a list</caption>\n    var membershipData = {\n      'email': 'TheDarkKnight@arkham.asylum',\n      'user_id': 4340598\n    };\n    memberships.create(membershipData)\n      .done(function (newMembership, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Accept a pending membership</caption>\n    var membershipID = 569859;\n    var membershipRevision = 0;\n    var acceptData = {\n      'state': 'accepted'\n    };\n    memberships.update(membershipID, membershipRevision, acceptData)\n      .done(function (membershipData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a membership</caption>\n    var membershipID = 569859;\n    var membershipRevision = 0;\n    memberships.delete(membershipID, membershipRevision)\n      .done(function (data, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar WBDeferred = core.WBDeferred;\n\nvar UserService = require('./User');\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/memberships',\n  'type': 'membership',\n\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.userService = new UserService(options);\n  },\n\n  'mine': function () {\n\n    var self = this;\n    var deferred = new WBDeferred();\n\n    self.userService.all()\n      .done(function (userData) {\n\n        self.forUser(userData.id)\n          .done(deferred.resolve, deferred)\n          .fail(deferred.reject, deferred);\n      })\n      .fail(deferred.reject, deferred);\n\n    return deferred.promise();\n  }\n});\n",
    "'use strict';\n\n/**\n  * Base mixin for service mixins.\n  * @module services/Mixins/BaseServiceMixin\n  * @extends wunderbits/WBMixin\n  * @requires validators/SchemaValidator\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\n\nvar SchemaValidator = require('../../validators/SchemaValidator');\n\nmodule.exports = WBMixin.extend({\n  /**\n    * Passes data to be sent to the API through validators/SchemaValidator to validate data attribute types\n    * @param {object} data - hash of key value pairs to be sent as part of request\n    * @param {string} type - the type of the data e.g. 'task', 'note', etc.\n    */\n  'validateData': function (data, type) {\n    SchemaValidator.validateData(data, type);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides convenience method for creating resources\n  * @module services/Mixin/ServiceCreate\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:CREATE');\n\nvar BaseServiceMixin = require('./BaseServiceMixin');\n\nmodule.exports = BaseServiceMixin.extend({\n\n  /**\n    * Creates a new resource instance view the type's baseURL\n    * @param {object} data - Data for the thing being created\n    * @param {string} [requestID] - Optional client supplied request id\n    *                               (will be auto generated otherwise)\n    * @returns {deferred} request - Request deferred object.\n    */\n  'create': function (data, requestID) {\n\n    var self = this;\n\n    var hasData = data && Object.keys(data).length;\n\n    try {\n      assert(hasData, 'Creation requires data.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    data = self.cleanCreateData(data);\n\n    try {\n      self.validateData(data, self.type);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    return self.post(self.baseUrl, data, requestID);\n  },\n\n  'cleanCreateData': function (data) {\n\n    for (var key in data) {\n      if (data[key] === null || data[key] === undefined) {\n        delete data[key];\n      }\n    }\n\n    return data;\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides convenience delete methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceDelete\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:DELETE');\n\nvar URLHelper = require('../../helpers/URL');\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Deletes an id from a resource path.\n    * @param {number} id - Id of the thing to delete.\n    * @param {number} revision - Current locally stored revision of the thing to delete.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'deleteID': function (id, revision, requestID) {\n\n    try {\n      assert.number(id, 'Deletion requires an id.');\n      assert.number(revision, 'Deletion requires a revision.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var params = {\n      'revision': revision\n    };\n\n    var paramString = URLHelper.compileParams(params);\n\n    var self = this;\n    return self['delete'](self.baseUrl + '/' + id + paramString, undefined, requestID);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides convenience methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceGet\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar WBMixin = core.WBMixin;\n\nmodule.exports = WBMixin.extend({\n\n  /**\n    * Performs a GET using the id as part of the URI\n    * @param {number} id - the id being fetched\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'getID': function (id, requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl + '/' + id, undefined, requestID);\n  },\n\n  /**\n    * Performs a GET using an arbitrary attribute and its id as params (?attribute=id)\n    * @param {string} url\n    * @param {string} attribute - the attribute\n    * @param {number|string} value - the attribute value\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'getItemsForAttribute': function (url, attribute, value, requestID) {\n\n    var self = this;\n    var data = {};\n\n    data[attribute] = value;\n\n    return self.get(url, data, requestID).promise();\n  },\n\n  /**\n    * Performs a GET for a user ID on the resource.\n    * @param {number} userId - The user id.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forUser': function (userId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'user_id', userId, requestID);\n  },\n\n  /**\n    * Performs a GET for a task ID on the resource.\n    * @param {number} taskId - The task ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forTask': function (taskId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'task_id', taskId, requestID);\n  },\n\n  /**\n    * Performs a GET for a list ID on the resource.\n    * @param {number} listId - The list ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forList': function (listId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl, 'list_id', listId, requestID);\n  },\n\n  /**\n    * Perform a GET for all data for a resource without any params.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'all': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl, undefined, requestID).promise();\n  },\n\n  /**\n    * Perform a GET for all data for a resource for all lists\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forAllLists': function (requestID) {\n\n    var self = this;\n    return self.get(self.baseUrl + '/lists', undefined, requestID);\n  },\n\n  /**\n    * Perform a GET for all data for a resource for all tasks scoped to a list id\n    * @param {number} listId - The list ID.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'forAllTasksForList': function (listId, requestID) {\n\n    var self = this;\n    return self.getItemsForAttribute(self.baseUrl + '/tasks', 'list_id', listId, requestID);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides update convenience methods for working with Wunderlist API endpoints.\n  * @module services/Mixin/ServiceUpdate\n  * @requires module:helpers/URL\n  * @requires module:wunderbits/WBMixin\n  * @extends module:wunderbits/WBMixin\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:UPDATE');\n\nvar BaseServiceMixin = require('./BaseServiceMixin');\n\nmodule.exports = BaseServiceMixin.extend({\n\n  /**\n    * Convenience method for sending resource updates.\n    * Handles converting nulls and undefineds to a remove hash.\n    * @param {number} id - Id of the thing to update.\n    * @param {number} revision - Last known revision of the thing to update.\n    * @param {object} updateData - The updates to send to the server.\n    * @param {string} [requestID] - Client supplied request ID\n    */\n  'update': function (id, revision, updateData, requestID) {\n\n    var self = this;\n    var hasData = updateData && Object.keys(updateData).length;\n\n    try {\n      assert.number(id, 'Updating a resource requires an id of type number.');\n      assert.number(revision, 'Updating a resource requires a revision of type number.');\n      assert(hasData, 'Updating a resource requires data to be sent.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0);\n    }\n\n    updateData.revision = revision;\n\n    self.validateData(updateData, self.type);\n\n    updateData = self.prepareDataForPatch(updateData);\n\n    return self.patch(self.baseUrl + '/' + id, updateData, requestID);\n  },\n\n  /**\n    * Iterates updateData for null and undefined keys and moves them to the remove array.\n    * @param {object} updateDate - The update data.\n    */\n  'prepareDataForPatch': function (updateData) {\n\n    var removals = [];\n    var value;\n\n    for (var key in updateData) {\n      value = updateData[key];\n      if (value === null || value === undefined) {\n        removals.push(key);\n        delete updateData[key];\n      }\n    }\n\n    if (removals.length) {\n      updateData.remove = removals;\n    }\n    return updateData;\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to note data.\n  * @module services/Notes\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Notes service</caption>\n    var NotesService = require('services/Notes');\n    var notes = new NotesService();\n\n  * @example <caption>Get notes for a task</caption>\n    var taskID = 78987;\n    notes.forTask(taskID)\n      .done(function (notesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get notes for a list</caption>\n    var listID = 87987;\n    notes.forList(listID)\n      .done(function (notesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific note</caption>\n    var noteID = 34958737;\n    notes.getID(noteID)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a note</caption>\n    var noteData = {\n      'task_id': 458748574,\n      'content': '2 + 2 = 5'\n    };\n    notes.create(noteData)\n      .done(function (noteData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a note</caption>\n    var noteID = 3487348374;\n    var revision = 45;\n    notes.deleteID(noteID, revision)\n      .always(function (resp, statusCode) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/notes',\n  'type': 'note',\n\n  /**\n    * Allows fetching notes for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch notes under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to file preview data.\n  * @module services/Previews\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Previews service</caption>\n    var PreviewsService = require('services/Previews');\n    var previews = new PreviewsService();\n\n  * @example <caption>Get preview for a file</caption>\n    var fileID = 87987;\n    previews.getPreview(fileID)\n      .done(function (previewData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/previews',\n  'type': 'preview',\n\n  // GET a.wunderlist.com/api/v1/files/:id/preview?platform=mac&size=retina\n  'getPreview': function (id, platform, size, requestID) {\n\n    var self = this;\n\n    var params = {\n      'file_id': id,\n      'platform': platform,\n      'size': size\n    };\n\n    return self.get(self.baseUrl, params, requestID);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to reminder data.\n  * @module services/Reminders\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Reminders service</caption>\n    var RemindersService = require('services/Reminders');\n    var reminders = new RemindersService();\n\n  * @example <caption>Get reminders for a task</caption>\n    var taskID = 349587;\n    reminders.forTask(taskID)\n      .done(function (remindersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get reminders for a list</caption>\n    var listID = 349587;\n    reminders.forList(listID)\n      .done(function (remindersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific reminder</caption>\n    var reminderID = 34958734958;\n    reminder.getID(reminderID)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a reminder</caption>\n    var reminderData = {\n      'task_id': 59191,\n      'date': '2013-08-30T08:29:46.203Z'\n    };\n    reminders.create(reminderData)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update a reminder</caption>\n    var reminderID = 349587;\n    var reminderRevision = 23;\n    var reminderUpdateData = {\n      'date': '2275-08-30T08:29:46.203Z'\n    };\n    reminders.update(reminderID, reminderRevision, reminderUpdateData)\n      .done(function (reminderData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a reminder</caption>\n    var reminderID = 2395872394;\n    reminders.deleteID(reminderID)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/reminders',\n  'type': 'reminder',\n\n  /**\n    * Allows fetching reminders for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch reminders under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to root.\n  * @module services/Root\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Root service</caption>\n    var RootService = require('services/Root');\n    var root = new RootService();\n\n  * @example <caption>Get a user's root object</caption>\n    root.all()\n      .done(function (rootData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/root',\n  'type': 'root'\n});\n",
    "'use strict';\n\n/**\n  * @module services/Service\n\n  * @requires module:wunderbits.core/WBEventEmitter\n\n  * @requires module:io/IO\n\n  * @requires module:services/Mixin/ServiceGet\n  * @requires module:services/Mixin/ServiceDelete\n  * @requires module:services/Mixin/ServiceCreate\n  * @requires module:services/Mixin/ServiceUpdate\n\n  * @extends module:wunderbits.core/WBEventEmitter\n\n  * @mixes module:services/Mixin/ServiceGet\n  * @mixes module:services/Mixin/ServiceDelete\n  * @mixes module:services/Mixin/ServiceCreate\n  * @mixes module:services/Mixin/ServiceUpdate\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar assert = core.lib.assert;\n\nvar ApplicationState = require('../models/ApplicationState');\nvar IOHttp = require('../io/IO');\n\nvar ServiceCreate = require('./Mixins/ServiceCreate');\nvar ServiceDelete = require('./Mixins/ServiceDelete');\nvar ServiceGet = require('./Mixins/ServiceGet');\nvar ServiceUpdate = require('./Mixins/ServiceUpdate');\n\nvar verbs = ['get', 'post', 'put', 'patch', 'delete'];\n\nvar _super = WBEventEmitter.prototype;\n\nvar BaseService = WBEventEmitter.extend({\n\n  'mixins': [\n    ServiceCreate,\n    ServiceDelete,\n    ServiceGet,\n    ServiceUpdate\n  ],\n\n  /**\n    * The service's base path. For example '/tasks' will become 'https://a.wunderlist.com/api/v1/tasks' when an HTTP request is made.\n    * @abstract\n    * @type {string}\n    */\n  'baseUrl': undefined,\n\n  /**\n    * The API version the service should use.\n    * @type {number}\n    */\n  'apiVersion': 1,\n\n  /**\n    * The service's resource type. For examples 'Task' for services/Tasks\n    * @abstract\n    * @type {string}\n    */\n  'type': undefined,\n\n  /**\n   * io helper\n   */\n  'io': undefined,\n\n  /**\n    * DELETE crud delete\n    * @method\n    */\n  'delete': undefined,\n\n  /**\n    * GET crud read\n    * @method\n    */\n  'get': undefined,\n\n  /**\n    * PATCH crud update\n    * @method\n    */\n  'patch': undefined,\n\n  /**\n    * POST crud create\n    * @method\n    */\n  'post': undefined,\n\n  /**\n    * PUT crud update\n    * @method\n    */\n  'put': undefined,\n\n  /**\n    * Base class for Wunderlist API service modules.\n    * @constructor\n    * @param {object} [options] - Class initialization options.\n    * @param {boolean} [options.websocket] - Proxy CRUD operations over a WebSocket.\n    * @alias module:services/Service\n    */\n  'initialize': function (options) {\n\n    var self = this;\n\n    _super.initialize.apply(self, arguments);\n\n    self.options = options = options || {};\n    self.appState = options.appState;\n\n    self.checkAppState();\n\n    self.baseUrl = '/v' + self.apiVersion + self.baseUrl;\n\n    if (self.options.websocket) {\n      self.setupSocketInterfaces();\n    }\n    else {\n      self.setupRestInterfaces();\n    }\n  },\n\n  'setupRestInterfaces': function () {\n\n    var self = this;\n\n    var io;\n\n    if (self.options.httpIO) {\n      io = self.options.httpIO;\n    }\n    else {\n      io = new IOHttp({\n        'config': self.appState.toJSON()\n      });\n    }\n\n    var http = self.io = io;\n\n    verbs.forEach(function (verb) {\n\n      self[verb] = http.io[verb];\n    });\n\n    self.bindTo(self.io, 'unauthorized', function () {\n\n      !self.destroyed && self.trigger('unauthorized');\n    });\n  },\n\n  /**\n    * Allows service to create its own local appstate if one is not passed\n    * in initialization options\n    */\n  'checkAppState': function () {\n\n    var self = this;\n\n    if (!self.appState && self.options.config) {\n      self.appState = new ApplicationState(self.options.config);\n      self.options.appState = self.appState;\n    }\n  },\n\n  /**\n    * Overrides default HTTP crud interfaces with RestSocket interfaces.\n    */\n  'setupSocketInterfaces': function () {\n\n    var self = this;\n    var socket = self.options.restSocket;\n\n    assert(socket, 'No RestSocket instance available.');\n\n    self.io = socket;\n\n    verbs.forEach(function (verb) {\n\n      self[verb] = self.io[verb];\n    });\n  },\n\n  /**\n    * Method to destroy and clean up instance.\n    */\n  'destroy': function () {\n\n    var self = this;\n\n    // clear all the bindings\n    self.unbindAll();\n\n    // delete all properties\n    // make sure a destroyed object is not keeping other\n    // objects alive by reference\n    function killEverything (obj) {\n      for (var key in obj) {\n        obj[key] = undefined;\n      }\n    }\n    killEverything(self);\n\n    // flag as destroyed, so objects internal methods\n    // can optionally check this before execution\n    self.destroyed = true;\n  },\n\n  /** TRUE when instance has been destroyed **/\n  'destroyed': false\n});\n\nmodule.exports = BaseService;\n",
    "'use strict';\n\n/**\n  * @module services/ServiceGetOnly\n  * @requires module:services/Service\n  * @requires module:services/Mixin/ServiceGet\n  * @mixes module:services/Mixin/ServiceGet\n  * @extends module:services/Service\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\n\nvar BaseService = require('./Service');\nvar ServiceGet = require('./Mixins/ServiceGet');\n\nvar IOHttp = require('../io/IO');\n\nvar notAllowed = function () {\n  throw new Error ('Method not allowed for this service.');\n};\n\nmodule.exports = BaseService.extend({\n\n  'mixins': [\n    ServiceGet\n  ],\n\n  'setupRestInterfaces': function () {\n\n    var self = this;\n\n    var http = self.io = new IOHttp({\n      'config': self.appState.toJSON()\n    });\n\n    self.get = http.io.get;\n  },\n\n  /**\n    * Overrides default HTTP crud interfaces with RestSocket interfaces.\n    */\n  'setupSocketInterfaces': function () {\n\n    var self = this;\n\n    var socket = self.options.restSocket;\n\n    assert(socket, 'No RestSocket instance available.');\n\n    self.io = socket;\n    self.get = self.io.get;\n  },\n\n  'delete': notAllowed,\n  'patch': notAllowed,\n  'post': notAllowed,\n  'put': notAllowed\n});\n",
    "'use strict';\n\n/**\n  * Provides access to oauth services\n  * @module services/Services\n  * @extends module:services/ServiceGetOnly\n  * @requires module:services/ServiceGetOnly\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/services',\n  'type': 'service'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to user settings.\n  * @module services/Settings\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Settings service</caption>\n    var SetttingsService = require('services/Settings');\n    var settings = new SetttingsService();\n\n  * @example <caption>Get all of a user's settings</caption>\n    settings.all()\n      .done(function (settingsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific setting</caption>\n    var settingID = 5458787;\n    settings.getID(settingID)\n      .done(function (settingData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a setting</caption>\n    var settingData = {\n      'key': 'difficulty',\n      'value': 'hard mode'\n    };\n    settings.create(settingData)\n      .done(function (settingData, statusCode) {\n\n      })\n      .fail(function (resp, code) {\n\n      });\n\n  * @example <caption>Update a setting</caption>\n    var settingID = 349587;\n    var settingRevision = 87;\n    var settingUpdateData = {\n      'value': 'insanity'\n    };\n\n    settings.update(settingID, settingRevision, settingUpdateData)\n      .done(function (settingData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a setting</caption>\n    var settingID = 349587;\n    var settingRevision = 88;\n    settings.deleteID(settingID, settingRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/settings',\n  'type': 'setting'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to task positions.\n  * @module services/SubtaskPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the SubtaskPositions service</caption>\n    var SubtaskPositionsService = require('services/SubtaskPositions');\n    var subtaskPositions = new SubtaskPositionsService();\n\n  * @example <caption>Get positions for a task's subtasks</caption>\n    var taskID = 123987;\n    subtaskPositions.forTask(taskID)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get subtasks positions for all tasks in a list</caption>\n    var listID = 123987;\n    subtaskPositions.forList(listID)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific subtask position object</caption>\n    var subtaskPositionID = 239487;\n    subtaskPositions.getID(subtaskPositionID)\n      .done(function (subtaskPositionData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update positions for a task's subtasks</caption>\n    var subtaskPositionsID = 349587;\n    var subtaskPositionsRevision = 23;\n    var updateData = {\n      'values': [2234,45645,76567,567978]\n    };\n    subtaskPositions.update(subtaskPositionsID, subtaskPositionsRevision, updateData)\n      .done(function (subtaskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/subtask_positions',\n  'type': 'subtask_position',\n\n  /**\n    * Allows fetching subtask_positions for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch subtask_positions under completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to subtasks data.\n  * @module services/Subtasks\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n* @example <caption>Create an instance of the Subtasks service</caption>\n    var SubtasksService = require('services/Subtasks');\n    var subtasks = new SubtasksService();\n\n  * @example <caption>Get all uncompleted subtasks for a list</caption>\n    var listID = 666;\n    subtasks.forList(listID)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed subtasks for a list</caption>\n    var listID = 3456\n    var completed = true;\n    subtasks.forList(listID, completed)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all uncompleted subtasks for a task</caption>\n    var taskID = 666;\n    subtasks.forTask(taskID)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed subtasks for a task</caption>\n    var taskID = 3456\n    var completed = true;\n    subtasks.forTask(taskID, completed)\n      .done(function (subtasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific subtask</caption>\n    vat subtaskID = 777;\n    subtasks.getID(subtaskID)\n      .done(function (subtaskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a subtask</caption>\n    subtasks.create({\n      'task_id': 8675309\n      'title': 'Call Jenny'\n    })\n    .done(function (subtaskData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a subtask</caption>\n    var subtaskID = 777;\n    var subtaskRevision = 5;\n    var updateData = {\n      'title': 'Change the world'\n    };\n    subtasks.update(subtaskID, subtaskRevision, updateData)\n      .done(function (subtaskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a subtask</caption>\n    var subtaskID = 777;\n    var subtaskRevision = 5;\n    subtasks.deleteID(subtaskID, subtaskRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:SUBTASKS');\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/subtasks',\n\n  'type': 'subtask',\n\n   /**\n    * Create a subtask.\n    * @param {object} data - Subtask creation data.\n    * @param {integer} data.task_id - Task ID which subtask belongs to.\n    * @param {string} data.title - Subtask title. Maximum length is 255 characters.\n    * @param {boolean} [data.completed] - Is subtask completed?\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Allows fetching either all or just uncompleted subtasks for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} [completed] - Fetch for completed tasks when TRUE\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n      'list_id': listId,\n      'completed_tasks': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n\n  /**\n    * Validates subtask creation data.\n    * @param {object} data - Subtask data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for subtask creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.task_id, 'data.task_id' + required);\n    assert.string(data.title, 'data.title' + required);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to task comments.\n  * @module services/TaskComments\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskComments service</caption>\n    var TaskCommentsService = require('services/TaskComments');\n    var taskComments = new TaskCommentsService();\n\n  * @example <caption>Get all comments for a task</caption>\n    var taskID = 239487;\n    taskComments.forTask(taskID)\n      .done(function (taskCommentsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get all task comments for all tasks in a list</caption>\n    var listID = 239487;\n    taskComments.forList(listID)\n      .done(function (taskCommentsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a task comment</caption>\n    taskComments.create({\n      'task_id': 349587,\n      'text': 'Hello world!'\n    })\n    .done(function (taskCommentData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Mark a task comment as having been read</caption>\n    var taskCommentID = 2394872;\n    var taskCommentRevision = 1;\n    var readData = {\n      'read': true\n    };\n    taskComments.update(taskCommentID, taskCommentRevision, readData)\n      .done(function (taskCommentData, statusCode) {\n        // ...\n      })\n      .fail(fucntion (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_comments',\n  'type': 'task_comment'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to task comments states\n  * @module services/TaskCommentsStates\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskCommentsStates service</caption>\n    var TaskCommentsStatesService = require('services/TaskCommentsStates');\n    var taskCommentsStates = new TaskCommentsStatesService();\n\n  * @example <caption>Get the comments states for a list</caption>\n    var listID = 239487;\n    taskCommentsStates.forList(listID)\n      .done(function (taskCommentsStatesData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_comments_states',\n  'type': 'task_comments_state'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to task positions.\n  * @module services/TaskPositions\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TaskPositions service</caption>\n    var TaskPositionsService = require('services/TaskPositions');\n    var taskPositions = new TaskPositionsService();\n\n  * @example <caption>Get task positions for a list</caption>\n    var listID = 123987;\n    taskPositions.forList(listID)\n      .done(function (taskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific task position object</caption>\n    var taskPositionID = 239487;\n    taskPositions.getID(taskPositionID)\n      .done(function (taskPositionData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update positions for a list's tasks</caption>\n    var taskPositionsID = 349587;\n    var taskPositionsRevision = 23;\n    var updateData = {\n      'values': [2234,45645,76567,567978]\n    };\n    taskPositions.update(taskPositionsID, taskPositionsRevision, updateData)\n      .done(function (taskPositionsData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/task_positions',\n  'type': 'task_position'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to tasks data.\n  * @module services/Tasks\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Tasks service</caption>\n    var TasksService = require('services/Tasks');\n    var tasks = new TasksService();\n\n  * @example <caption>Get all uncompleted tasks for a list</caption>\n    var listID = 666;\n    tasks.forList(listID)\n      .done(function (tasksData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get completed tasks for a list</caption>\n    var listID = 3456;\n    var completed = true;\n    tasks.forList(listID, completed)\n      .done(function (tasks, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Get a specific task</caption>\n    vat taskID = 777;\n    tasks.getID(taskID)\n      .done(function (taskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Create a task</caption>\n    tasks.create({\n      'list_id': 8675309\n      'title': 'Call Jenny'\n    })\n    .done(function (taskData, statusCode) {\n      // ...\n    })\n    .fail(function (resp, code) {\n      // ...\n    });\n\n  * @example <caption>Update a task</caption>\n    var taskID = 777;\n    var taskRevision = 5;\n    var updateData = {\n      'title': 'Change the world',\n      'starred': true,\n      'due_data': undefined\n    };\n\n    tasks.update(taskID, revision, updateData)\n      .done(function (taskData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Delete a task</caption>\n    var taskID = 777;\n    var taskRevision = 5;\n    tasks.deleteID(taskID, taskRevision)\n      .always(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:TASKS');\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nvar _super = AuthenticatedService.prototype;\nmodule.exports = AuthenticatedService.extend({\n\n  'baseUrl': '/tasks',\n\n  'type': 'task',\n\n  /**\n    * Allows fetching either all or just uncompleted tasks for a list.\n    * @param {string} listId - The list to fetch.\n    * @param {boolean} completed - Fetch completed tasks or not.\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    */\n  'forList': function (listId, completed, requestID) {\n\n    var self = this;\n\n    var request = self.get(self.baseUrl, {\n\n      'list_id': listId,\n      'completed': !!completed\n    }, requestID);\n\n    return request.promise();\n  },\n\n  /**\n    * Create a task.\n    * @param {object} data - Task data.\n    * @param {integer} data.list_id - List ID in which to create task.\n    * @param {string} data.title - Task title.\n    * @param {integer} [data.assignee_id] - User task is assigned to.\n    * @param {boolean} [data.completed] - Is task completed?\n    * @param {string} [data.due_date] - Task due date formatted as an ISO8601 date.\n    * @param {boolean} [data.starred] - Is task starred?\n    * @param {string} [requestID] - User supplied Request ID. Autogenerated if not supplied.\n    * @returns {promise} Promise of request deferred.\n    */\n  'create': function (data) {\n\n    var self = this;\n    try {\n      self.validateCreateData(data);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    var request = _super.create.apply(self, arguments);\n    return request.promise();\n  },\n\n  /**\n    * Validates task creation data.\n    * @param {object} data - Task data.\n    */\n  'validateCreateData': function (data) {\n\n    data = data || {};\n\n    var hasData = Object.keys(data).length;\n    var required = ' required for task creation';\n    assert(hasData, 'data' + required);\n    assert.number(data.list_id, 'data.list_id' + required);\n    assert.string(data.title, 'data.title' + required);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to tasks_count data.\n  * @module services/TasksCount\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the TasksCount service</caption>\n    var TasksCountService = require('services/TasksCount');\n    var taskCounts = new TasksCountService();\n\n  * @example <caption>Get a list's task counts</caption>\n    var listID = 4349587;\n    taskCounts.forList(listID)\n      .done(function (taskCounts, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/lists/tasks_count',\n  'type': 'tasks_count'\n});\n",
    "'use strict';\n\n/**\n  * Provides access to unread counts for Activities and Comments\n  * @module services/UnreadCounts\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Get unread counts for Activities and Comments</caption>\n    var UnreadCountsService = require('services/UnreadCounts');\n    var unreadCounts = new UnreadCountsService();\n    unreadCounts.all()\n      .done(function (data, statusCode) {\n        console.log(data.comments);\n        console.log(data.activities);\n      })\n      .fail(function () {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/unread_activity_counts',\n  'type': 'unread_activities_count'\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to uploads data.\n  * @module services/Uploads\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Uploads service</caption>\n    var UploadsService = require('services/Uploads');\n    var uploads = new FilesService();\n\n  * @example <caption>Create a upload</caption>\n\n    uploads.create()\n      .done(function (uploadData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n\n  * @example <caption>Update a upload</caption>\n    var uploadID = 777;\n    var uploadRevision = 2398;\n    var updateData = {\n      'state': 'finished'\n    };\n    uploads.update(uploadID, uploadRevision, updateData)\n      .done(function (uploadData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/uploads',\n  'type': 'upload',\n\n  // upload creation does not require data, but preserving\n  'create': function (data, requestID) {\n\n    var self = this;\n    return self.post(self.baseUrl, data, requestID);\n  },\n\n  'getPart': function (id, partNumber, requestID) {\n\n    var self = this;\n\n    var params = {\n      'part_number': partNumber\n    };\n\n    return self.get(self.baseUrl + '/' + id + '/parts', params, requestID);\n  },\n\n  'finish': function (id, requestID) {\n\n    var self = this;\n\n    var params = {\n      'state': 'finished'\n    };\n\n    return self.patch(self.baseUrl + '/' + id, params, requestID);\n  }\n});",
    "'use strict';\n\n/**\n  * Provides methods for easy access to user data for\n  * the currently signed in user.\n  * @module services/User\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the User service</caption>\n    var UserService = require('services/User');\n    var user = new UserService();\n\n  * @example <caption>Fetch all info for the currently logged in user</caption>\n    user.all()\n      .done(function (userData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar core = require('wunderbits.core');\nvar assert = core.lib.assert;\nvar WBDeferred = core.WBDeferred;\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SERVICE:USER');\n\nvar AuthenticatedService = require('./AuthenticatedService');\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/user',\n  'type': 'user',\n\n  'update': function (revision, updateData, requestID) {\n\n    var self = this;\n    var hasData = updateData && Object.keys(updateData).length;\n\n    try {\n      assert.number(revision, 'Updating a user requires a revision of type number.');\n      assert(hasData, 'Updating a user requires data to be sent.');\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0).promise();\n    }\n\n    updateData.revision = revision;\n\n    try {\n      self.validateData(updateData, self.type);\n    }\n    catch (e) {\n      localConsole.error(e);\n      return new WBDeferred().reject({\n        'errors': [e.toString()]\n      }, 0);\n    }\n\n    updateData = self.prepareDataForPatch(updateData);\n\n    return self.patch(self.baseUrl, updateData, requestID);\n  },\n\n  'changeEmail': function (newEmail, password, requestID) {\n\n    var self = this;\n\n    var data = {\n      'email': newEmail,\n      'password': password\n    };\n\n    return self.patch(self.baseUrl + '/email', data, requestID);\n  },\n\n  'changePassword': function (newPassword, currentPassword, requestID) {\n\n    var self = this;\n\n    var updateData = {\n      'password': newPassword,\n      'old_password': currentPassword\n    };\n\n    return self.patch(self.baseUrl + '/password', updateData, requestID);\n  },\n\n  'deleteSelf': function (password, requestID) {\n\n    var self = this;\n\n    var params = {\n      'password': password\n    };\n\n    return self['delete'](self.baseUrl, params, requestID);\n  }\n});\n",
    "'use strict';\n\n/**\n  * Provides methods for easy access to users data.\n  * @module services/Users\n  * @extends module:services/AuthenticatedService\n  * @requires module:services/AuthenticatedService\n\n  * @example <caption>Create an instance of the Users service</caption>\n    var UsersService = require('services/Users');\n    var users = new UsersService();\n\n  * @example <caption>Fetch the users this logged in user can access</caption>\n    users.all()\n      .done(function (usersData, statusCode) {\n        // ...\n      })\n      .fail(function (resp, code) {\n        // ...\n      });\n  */\n\nvar AuthenticatedService = require('./AuthenticatedService');\n\nmodule.exports = AuthenticatedService.extend({\n  'baseUrl': '/users',\n  'type': 'user'\n});\n",
    "'use strict';\n\nvar ServiceGetOnly = require('./ServiceGetOnly');\n\nvar services = {\n  'activities': require('./Activities'),\n  'conversations': require('./Conversations'),\n  'export': require('./Export'),\n  'features': require('./Features'),\n  'files': require('./Files'),\n  'import': require('./Import'),\n  'ical_feed': require('./IcalFeed'),\n  'list_positions': require('./ListPositions'),\n  'list_reminders_collections': require('./ListRemindersCollections'),\n  'lists': require('./Lists'),\n  'memberships': require('./Memberships'),\n  'notes': require('./Notes'),\n  'previews': require('./Previews'),\n  'reminders': require('./Reminders'),\n  'root': require('./Root'),\n  // Services.js in order not confuse dependency tree with folder services/index.js\n  'services': require('./Services.js'),\n  'settings': require('./Settings'),\n  'subtask_positions': require('./SubtaskPositions'),\n  'subtasks': require('./Subtasks'),\n  'task_comments': require('./TaskComments'),\n  'task_comments_states': require('./TaskCommentsStates'),\n  'task_positions': require('./TaskPositions'),\n  'tasks': require('./Tasks'),\n  'tasks_counts': require('./TasksCounts'),\n  'unread_activities_counts': require('./UnreadActivitiesCounts'),\n  'uploads': require('./Uploads'),\n  'user': require('./User'),\n  'users': require('./Users')\n};\n\nvar revisionedEndpoints = [\n  // 'file',\n  'list',\n  // 'folder',\n  // 'list_position',\n  // 'membership',\n  // 'note',\n  // 'reminder',\n  // 'service',\n  // 'setting',\n  // 'subscription',\n  // 'subtask',\n  // 'subtask_position',\n  'task'\n  // 'task_comment',\n  // 'task_position',\n  // 'upload',\n  // 'user'\n];\n\nrevisionedEndpoints.forEach(function (type) {\n\n  var revisionEndpoint = type + '_revisions';\n  services[revisionEndpoint] = ServiceGetOnly.extend({\n    'baseUrl': '/' + revisionEndpoint,\n    'type': revisionEndpoint\n  });\n});\n\nmodule.exports = services;\n",
    "'use strict';\n\n/**\n  * @module validators/SchemaValidator\n  * @extends wunderbits/WBSingleton\n  * @requires module:schema/List\n  * @requires module:schema/Subtask\n  * @requires module:schema/Task\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SCHEMAVALIDATOR');\n\nvar _schemas = require('../schemas');\n\nvar _validatorByType = {\n  'array': 'isArray',\n  'integer': 'isInteger',\n  'boolean': 'isBoolean',\n  'string': 'isString',\n  'ISODate': 'isISODate'\n};\n\nvar SchemaValidator = WBSingleton.extend({\n\n  /**\n    * Validates a data object based on a schema\n    * @param {object}\n    */\n  'validateData': function (data, type) {\n\n    var self = this;\n    var isAllDataIsValid = true;\n    var dataType, validtor, isValid, value;\n\n    var schema = _schemas[type];\n\n    if (!schema) {\n      localConsole.warn('No data schema for type \"' + type + '\"');\n      return true;\n    }\n\n    for (var key in data) {\n\n      isValid = undefined;\n      dataType = schema[key];\n\n      if (!dataType) {\n        localConsole.warn('No validation set for key', key, 'for', type);\n      }\n\n      value = data[key];\n      validtor = self[_validatorByType[dataType]];\n\n      if (validtor) {\n        isValid = validtor.call(self, value);\n        if (!isValid) {\n          localConsole.warn(type + ' value ' + value + ' (' + typeof value + ') for key \"' + key + '\"\" did not pass validation for type ' + dataType);\n          isAllDataIsValid = false;\n        }\n        else {\n          // localConsole.debug('Value ' + value + ' (' + typeof value + ') for key \"' + key + '\"\" passed validation for type ' + dataType);\n        }\n      }\n    }\n\n    return isAllDataIsValid;\n  },\n\n  /**\n    * Returns true if is an Array\n    * @param {object} variable - The thing to check for Arrayness\n    */\n  'isArray': function (variable) {\n\n    return Array.isArray(variable);\n  },\n\n  /**\n    * Returns true if is a Boolean\n    * @param {object} variable - The thing to check for Booleaness\n    */\n  'isBoolean': function (variable) {\n\n    return variable === false || variable === true;\n  },\n\n  /**\n    * Returns true if is an Integer\n    * @param {object} variable - The thing to check for Integerness\n    */\n  'isInteger': function (variable) {\n\n    // http://stackoverflow.com/questions/3885817/how-to-check-if-a-number-is-float-or-integer\n    return typeof variable === 'number' && parseFloat(variable) === parseInt(variable, 10) && !isNaN(variable);\n  },\n\n  /**\n    * Returns true if is a String\n    * @param {object} variable - The thing to check for Stringness\n    */\n  'isString': function (variable) {\n\n    return typeof variable === 'string';\n  },\n\n  /**\n    * Returns true if is an ISO Date string\n    * @param {object} variable - The thing to check for ISO Dateness\n    */\n  'isISODate': function (variable) {\n\n    var self = this;\n\n    // do not even regex if not a string\n    if (!self.isString(variable)) {\n      return false;\n    }\n\n    var ISODate = /^\\d{4}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-2])T(0[0-9]|1[0-9]|2[0-3])(:([0-5][0-9])){2}(\\.\\d{3})?Z$/;\n    return ISODate.test(variable);\n  }\n});\n\nmodule.exports = SchemaValidator;\n",
    "(function (global){\n'use strict';\n\n\n// Network connectivity monitor.\n// Based on http://robertnyman.com/html5/offline/online-offline-events.html\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\n\nvar HealthCheck = require('../helpers/HealthCheck');\n\nvar navigator = global.navigator || { 'onLine': true };\n\nvar WBOnlineStatus = WBEventEmitter.extend({\n\n  'online': null,\n\n  'initialize': function (options) {\n\n    var self = this;\n    var document = global.document;\n\n    self.online = navigator.onLine;\n\n    if (global.addEventListener) {\n      // normal browsers\n      global.addEventListener('online', self.onOnline.bind(self), false);\n      global.addEventListener('offline', self.onOffline.bind(self), false);\n    }\n    // ie ?\n    else if (document) {\n      var body = document.body;\n      body.ononline = self.isOnline;\n      body.onoffline = self.isOffline;\n    }\n\n    options.config.checkHealth && self.bindToApiHealth(options);\n  },\n\n  'destroy': function () {\n\n    HealthCheck.destroy();\n  },\n\n  'bindToApiHealth': function (options) {\n\n    var self = this;\n\n    HealthCheck.init(options);\n\n    self.bindTo(HealthCheck, 'healthy', 'onOnline');\n    self.bindTo(HealthCheck, 'unhealthy', 'onOffline');\n  },\n\n  'isOnline': function () {\n\n    return this.online;\n  },\n\n  'onOnline': function () {\n\n    var self = this;\n    self.online = true;\n    self.trigger('online');\n  },\n\n  'onOffline': function () {\n\n    var self = this;\n    self.online = false;\n    self.trigger('offline');\n  }\n});\n\nmodule.exports = WBOnlineStatus;\n\n}).call(this,typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})",
    "'use strict';\n\n/**\n  * Parse different data types to things\n  * @module wunderbits/lib/SafeParse\n  * @extends module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits.core/WBSingleton\n  * @requires module:wunderbits/lib/console\n  */\n\nvar core = require('wunderbits.core');\nvar WBSingleton = core.WBSingleton;\n\nvar MagiConsole = require('magiconsole');\nvar localConsole = new MagiConsole('SDK:SAFEPARSE');\n\nvar SafeParse = WBSingleton.extend({\n\n  /**\n    * Apptempts to parse a json sring to an object without throwing\n    * unhandled errors.  Returns undefined if unable to parse json string.\n    */\n  'json': function (jsonString) {\n\n    try {\n      return JSON.parse(jsonString);\n    } catch (e) {\n      localConsole.warn('Unable to parse \"' + jsonString + '\"');\n    }\n    return;\n  }\n});\n\nmodule.exports = SafeParse;",
    "'use strict';\n\nvar core = require('wunderbits.core');\nvar functions = core.lib.functions;\n\n// because lodash and underscore do some stupids\nvar arrRef = [];\n\n// always use native bind regardless of \"speed\", we want less closures!\nvar bindAll = (function () {\n  return function (object) {\n    var fns = arguments.length > 1 ? arrRef.concat.apply(arrRef, arrRef.slice.call(arguments, 1)) : functions(object);\n    var key;\n\n    while (fns.length) {\n      key = fns.shift();\n      if (key !== 'constructor') {\n        object[key] = object[key].bind(object);\n      }\n    }\n  };\n})();\n\nmodule.exports = bindAll;\n",
    "'use strict';\n\n/**\n  * @module wunderlist/Wunderlist\n\n  * @requires module:wunderbits.core/WBEventEmitter\n  * @requires module:wunderbits/lib/dependencies\n\n  * @requires module:services/Lists\n  * @requires module:services/Memberships\n  * @requires module:services/Notes\n  * @requires module:services/Reminders\n  * @requires module:services/Settings\n  * @requires module:services/Subtasks\n  * @requires module:services/Tasks\n  * @requires module:services/UserEvents\n  * @requires module:services/Activities\n  * @requires module:services/Conversations\n  * @requires module:services/UnreadCounts\n\n  * @requires module:io/RestSocket\n  *\n  * @extends module:wunderbits.core/WBEventEmitter\n\n  * @example <caption>Create an instance of the main Wunderlist class</caption>\n    var WunderlistSDK = require('wunderlist/Wunderlist');\n\n    // Returns an instance of the Wunderlist SDK setup with the correct client ID and user access token\n    // and sets up a single WebSocket connection for REST over socket proxying\n    var wunderlistSDK = new WunderlistSDK({\n      'accessToken': 'a user token',\n      'clientID': 'your application id'\n    });\n\n    wunderlistSDK.initialized.done(function () {\n      // Where handleListData and handleError are functions\n      // 'http' here can be replaced with 'socket' to use a WebSocket connection for all requests\n      wunderlistSDK.http.lists.all()\n        // handleListData will be called with the object parsed from the response JSON\n        .done(handleListData)\n        // handleError will be called with the error/event\n        .fail(handleError);\n    });\n\n  */\n\nvar core = require('wunderbits.core');\nvar WBEventEmitter = core.WBEventEmitter;\nvar WBDeferred = core.WBDeferred;\nvar extend = core.lib.extend;\n\nvar AjaxTransport = require('../io/io/AjaxTransport');\nvar config = require('../config/default');\nvar ApplicationStateModel = require('../models/ApplicationState');\nvar IOHttp = require('../io/IO');\nvar RestSocket = require('../io/RestSocket');\nvar PlatformHeaders = require('../helpers/PlatformHeaders');\nvar ServiceClasses = require('../services');\n\nvar MagiConsole = require('magiconsole');\n\nvar _super = WBEventEmitter.prototype;\n\nvar Wunderlist = WBEventEmitter.extend({\n\n  /**\n    * @todo revisit in the future and remove,\n    * auth will probably only be available through OAuth.\n    */\n  'auth': undefined,\n\n  /**\n    * Deferred object for tracking initialization success or failure.\n    * @type {deferred}\n    */\n  'state': undefined,\n\n  /**\n    * Flag to denote network connectivity.\n    * Note: this flag is only to denote a network connection, not API status.\n    */\n  'online': undefined,\n\n  /**\n    * State promise for attaching to initialization events.  Promise of state.\n    * @type {promise}\n    */\n  'initialized': undefined,\n\n  /**\n    * Holds references to instances of API HTTP service modules once Wunderlist initialization is completed and successful.\n    * @type {object}\n    * @property {instance} [lists] - HTTP Instance of {@link module:services/Lists}\n    * @property {instance} [memberships] - HTTP Instance of {@link module:services/Memberships}\n    * @property {instance} [notes]- HTTP Instance of {@link module:services/Notes}\n    * @property {instance} [reminders] - HTTP Instance of {@link module:services/Reminders}\n    * @property {instance} [settings] - HTTP Instance of {@link module:services/Settings}\n    * @property {instance} [subtasks] - HTTP Instance of {@link module:services/Subtasks}\n    * @property {instance} [tasks] - HTTP Instance of {@link module:services/Tasks}\n    * @property {instance} [userEvents] - HTTP Instance of {@link module:services/UserEvents}\n    */\n  'http': undefined,\n\n  /**\n    * Holds references to instances of API WebSocket service modules once Wunderlist initialization is completed and successful.\n    * @type {object}\n    * @property {instance} [lists] - WebSocket Instance of {@link module:services/Lists}\n    * @property {instance} [memberships] - WebSocket Instance of {@link module:services/Memberships}\n    * @property {instance} [notes]- WebSocket Instance of {@link module:services/Notes}\n    * @property {instance} [reminders] - WebSocket Instance of {@link module:services/Reminders}\n    * @property {instance} [settings] - WebSocket Instance of {@link module:services/Settings}\n    * @property {instance} [subtasks] - WebSocket Instance of {@link module:services/Subtasks}\n    * @property {instance} [tasks] - WebSocket Instance of {@link module:services/Tasks}\n    * @property {instance} [userEvents] - WebSocket Instance of {@link module:services/UserEvents}\n    */\n  'socket': undefined,\n\n  /**\n    * Main interface to Wunderlist API service modules.\n    * @constructor\n    * @param {object} options - Class initialization options.\n    * @param {string} options.clientID - Client ID is required.\n    * @param {string} options.accessToken - Wunderlist access token.\n    * @param {array} [options.services] - Services to be initialize.\n    *     If not present, all service modules will be initialized.\n    *     ex: 'services': ['lists', 'tasks']\n    * @param {boolean} [options.debug] - Enable logging\n    * @alias module:wunderlist/Wunderlist\n    */\n  'initialize': function (options) {\n\n    var self = this;\n    _super.initialize.apply(self, arguments);\n\n    self.options = options = extend(config, options || {});\n\n    self.setupLogging(self.options);\n\n    self.validateOptions();\n\n    self.appState = new ApplicationStateModel(options);\n\n    // initialise PlatformHeader\n    PlatformHeaders.init(options);\n\n    var state = self.state = new WBDeferred();\n    self.initialized = self.state.promise();\n\n    self.online = self.appState.isOnline();\n\n    self.start()\n      .done(state.resolveWith, state, self)\n      .fail(state.reject, state);\n  },\n\n  'setupLogging': function (options) {\n\n    options.logLevel && MagiConsole.setLevel(options.logLevel);\n    options.logPattern && MagiConsole.setPattern(options.logPattern);\n  },\n\n  /**\n    * Returns true once self.initialized is resolved.\n    * @type {boolean}\n    */\n  'isInitialized': function () {\n\n    var self = this;\n    return !!(self.initialized && self.initialized.state() === 'resolved');\n  },\n\n  /**\n    * Calls services initialization if/once authorized\n    * @returns {promise}\n    */\n  'start': function () {\n\n    var self = this;\n    var promise;\n\n    promise = self.getServices();\n\n    // watch online state\n    self.bindTo(self.appState, 'change:online', 'onOnlineOffline');\n\n    // report timings\n    self.bindTo(AjaxTransport, 'timing:io', 'onIOTiming');\n\n    return promise;\n  },\n\n  /**\n    * Set self.online state and trigger exposed online/offline event\n    */\n  'onOnlineOffline': function () {\n\n    var self = this;\n    self.online = self.appState.isOnline();\n    self.trigger(self.online ? 'online' : 'offline');\n  },\n\n  'onIOTiming': function (ioTimingData) {\n\n    var self = this;\n    self.trigger('timing:io', ioTimingData);\n  },\n\n  /**\n    * Creates instances of service modules according to initialization options.\n    * @param {array} [services] - Array of services to initialize.\n    * Default is initialize all services.\n    * @returns {promise} Hash of initialized services.\n    */\n  'getServices': function () {\n\n    var self = this;\n\n    var compiledServices = {\n      'http': {},\n      'socket': {}\n    };\n    var service, services, Klass;\n    var deferred = new WBDeferred();\n\n    var accessToken = self.appState.attributes.accessToken;\n\n    self.createSocket(accessToken).done(function createServices () {\n\n      // clear old services\n      self.http = undefined;\n      self.socket = undefined;\n\n      // from args, options, or default to all\n      services = services || self.options.services || Object.keys(ServiceClasses);\n\n      self.httpIO = new IOHttp({\n        'config': self.appState.toJSON()\n      });\n\n      for (var i = 0, len = services.length; i < len; i++) {\n        service = services[i];\n        Klass = ServiceClasses[service];\n\n        // http service\n        compiledServices.http[service] = new Klass({\n          'appState': self.appState,\n          'httpIO': self.httpIO\n        });\n        self.bindTo(compiledServices.http[service], 'unauthorized', self.onUnauthorized);\n\n        // socket service\n        compiledServices.socket[service] = new Klass({\n          'websocket': true,\n          'restSocket': self.restSocket,\n          'appState': self.appState\n        });\n      }\n\n      self.http = compiledServices.http;\n      self.socket = compiledServices.socket;\n\n      deferred.resolve(compiledServices);\n    });\n\n    return deferred.promise();\n  },\n\n  'isSocketOnline': function () {\n\n    var self = this;\n\n    var restSocket = self.restSocket;\n    var socket = restSocket && restSocket.socket;\n    var webSocketConnected = !!(socket && socket.isConnected());\n\n    return webSocketConnected;\n  },\n\n  /**\n    * Returns self.socket or self.http depending on self.restSocket.socket.connected\n    */\n  'getOutlet': function () {\n\n    var self = this;\n\n    var webSocketConnected = self.isSocketOnline();\n    var forcedHttp = !!self.options.forceHTTP;\n\n    return (webSocketConnected && !forcedHttp) ? self.socket : self.http;\n  },\n\n  /**\n    * Creates an instance of RestSocket using the current appState configuration\n    * @fires module:wunderlist/Wunderlist#event\n    * @returns {promise} Promise of WebSocket ready deferred\n    */\n  'createSocket': function () {\n\n    var self = this;\n\n    self.restSocket && self.unbindFrom(self.restSocket);\n\n    var restSocket = new RestSocket({\n      'appState': self.appState,\n      'config': self.options\n    });\n    self.restSocket = restSocket;\n\n    self.bindTo(restSocket, 'event', function (data) {\n\n      /**\n        * Realtime events messages event.\n        * @event module:wunderlist/Wunderlist#event\n        * @type {object}\n        */\n      self.trigger('event', data);\n    });\n\n    self.bindTo(restSocket, 'desktopNotification', function (data) {\n\n      /**\n        * Realtime desktop notifications.\n        * @event module:wunderlist/Wunderlist#desktopNotification\n        * @type {object}\n        */\n      self.trigger('desktopNotification', data);\n    });\n\n    self.bindTo(restSocket, 'unauthorized', self.onUnauthorized);\n    self.bindTo(restSocket, 'timing:io', 'onIOTiming');\n\n    return restSocket.ready.promise();\n  },\n\n  /**\n    * Destroys instance of Wunderlist on unauthorized event.\n    */\n  'onUnauthorized': function () {\n\n    var self = this;\n    self.trigger('unauthorized');\n    self.destroy();\n  },\n\n  /**\n    * Method to destroy and clean up instance.\n    */\n  'destroy': function () {\n\n    var self = this;\n\n    // kill the socket\n    self.restSocket && self.restSocket.destroy();\n\n    // clear all the bindings\n    self.unbindAll();\n\n    // destroy all the services\n    var protocols = ['http', 'socket'];\n    protocols.forEach(function (protocol) {\n\n      var theService;\n      for (var service in self[protocol]) {\n        theService = self[protocol][service];\n        theService.destroy && theService.destroy();\n      }\n      self[protocol] = undefined;\n    });\n\n    self.appState.destroy();\n\n    // delete all properties\n    // make sure a destroyed object is not keeping other\n    // objects alive by reference\n    function killEverything (obj) {\n      for (var key in obj) {\n        obj[key] = undefined;\n      }\n    }\n    killEverything(self);\n\n    // flag as destroyed, so objects internal methods\n    // can optionally check this before execution\n    self.destroyed = true;\n  },\n\n  /** TRUE when instance has been destroyed */\n  'destroyed': false,\n\n  /**\n    * Validates initialization options\n    * @returns {boolean} True if options are valid\n    */\n  'validateOptions': function () {\n\n    var self = this;\n    var options = self.options || {};\n\n    var validAuthCredentials = !!options.accessToken;\n    if (!options.clientID || !validAuthCredentials) {\n      throw new Error('Cannot initialize the Wunderlist SDK without a Client ID or auth credentials');\n    }\n  },\n\n  'cancelInflightCreate': function (requestID, onlineID, revision) {\n\n    var self = this;\n\n    var restSocket = self.restSocket;\n    var httpIO = self.httpIO;\n    restSocket && restSocket.cancelInflightCreate(requestID, onlineID, revision);\n    httpIO && httpIO.cancelInflightCreate(requestID, onlineID, revision);\n  }\n}, {\n  'services': ServiceClasses,\n  'headers': PlatformHeaders\n});\n\nmodule.exports = Wunderlist;\n"
  ]
}